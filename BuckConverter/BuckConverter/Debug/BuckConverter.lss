
BuckConverter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  0000117c  00001210  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000117c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000cc  0080011e  0080011e  0000122e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000122e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001260  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  000012a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001cb1  00000000  00000000  00001448  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d36  00000000  00000000  000030f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000eed  00000000  00000000  00003e2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003e4  00000000  00000000  00004d1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000768  00000000  00000000  00005100  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c9d  00000000  00000000  00005868  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  00006505  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 04 03 	jmp	0x608	; 0x608 <__vector_1>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 71 04 	jmp	0x8e2	; 0x8e2 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 86 04 	jmp	0x90c	; 0x90c <__vector_14>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 42 06 	jmp	0xc84	; 0xc84 <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 36 06 	jmp	0xc6c	; 0xc6c <__vector_20>
      54:	0c 94 83 02 	jmp	0x506	; 0x506 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e7       	ldi	r30, 0x7C	; 124
      7c:	f1 e1       	ldi	r31, 0x11	; 17
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 31       	cpi	r26, 0x1E	; 30
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	21 e0       	ldi	r18, 0x01	; 1
      8c:	ae e1       	ldi	r26, 0x1E	; 30
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	aa 3e       	cpi	r26, 0xEA	; 234
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 53 00 	call	0xa6	; 0xa6 <main>
      9e:	0c 94 bc 08 	jmp	0x1178	; 0x1178 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <main>:
#include <util/delay.h>



int main(void)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	cd b7       	in	r28, 0x3d	; 61
      ac:	de b7       	in	r29, 0x3e	; 62
      ae:	ce 50       	subi	r28, 0x0E	; 14
      b0:	d1 40       	sbci	r29, 0x01	; 1
      b2:	0f b6       	in	r0, 0x3f	; 63
      b4:	f8 94       	cli
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	0f be       	out	0x3f, r0	; 63
      ba:	cd bf       	out	0x3d, r28	; 61
    ADC_init();
      bc:	0e 94 4d 01 	call	0x29a	; 0x29a <ADC_init>
	uart_init();
      c0:	0e 94 6d 06 	call	0xcda	; 0xcda <uart_init>
	pwm_init();
      c4:	0e 94 57 04 	call	0x8ae	; 0x8ae <pwm_init>
	tajmer0_init();
      c8:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <tajmer0_init>
	i2c_init();
      cc:	0e 94 48 03 	call	0x690	; 0x690 <i2c_init>
	lcd1602_init();
      d0:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <lcd1602_init>
	
	sei();
      d4:	78 94       	sei
	int i = 0;
	
	unsigned long AVG_mereni_napon = 0;
	
	
	lcd1602_clear();
      d6:	0e 94 2d 04 	call	0x85a	; 0x85a <lcd1602_clear>
	lcd1602_goto_xy(5,0);
      da:	60 e0       	ldi	r22, 0x00	; 0
      dc:	70 e0       	ldi	r23, 0x00	; 0
      de:	85 e0       	ldi	r24, 0x05	; 5
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
	lcd1602_send_string("mV");
      e6:	80 e1       	ldi	r24, 0x10	; 16
      e8:	91 e0       	ldi	r25, 0x01	; 1
      ea:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
	lcd1602_goto_xy(5,1);
      ee:	61 e0       	ldi	r22, 0x01	; 1
      f0:	70 e0       	ldi	r23, 0x00	; 0
      f2:	85 e0       	ldi	r24, 0x05	; 5
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
	lcd1602_send_string("mA");
      fa:	83 e1       	ldi	r24, 0x13	; 19
      fc:	91 e0       	ldi	r25, 0x01	; 1
      fe:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
     102:	8e 01       	movw	r16, r28
     104:	09 51       	subi	r16, 0x19	; 25
     106:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     108:	0f 2e       	mov	r0, r31
     10a:	f4 e6       	ldi	r31, 0x64	; 100
     10c:	8f 2e       	mov	r8, r31
     10e:	91 2c       	mov	r9, r1
     110:	a1 2c       	mov	r10, r1
     112:	b1 2c       	mov	r11, r1
     114:	f0 2d       	mov	r31, r0
     116:	fe 01       	movw	r30, r28
     118:	7f 96       	adiw	r30, 0x1f	; 31
#include <util/delay.h>



int main(void)
{
     11a:	df 01       	movw	r26, r30
		AVG_mereni_napon =0;
		
		for(i=0; i<br_uzoraka; i++)
		{
			
			niz_mereni_napon[i] = mereni_napon;
     11c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <mereni_napon>
     120:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <mereni_napon+0x1>
     124:	8d 93       	st	X+, r24
     126:	9d 93       	st	X+, r25
    {
		/*napomena: ovakaj dole pokusaj uzimanja srednje vrednosti ne pije vodu jer su petlje prebrze za ad rezultate, tako da se 
		zapravo mali broj ad rezultata obradi, mozda nekoliko. Potrebno je ovo provuci kroz tajmer*/
		AVG_mereni_napon =0;
		
		for(i=0; i<br_uzoraka; i++)
     128:	a0 17       	cp	r26, r16
     12a:	b1 07       	cpc	r27, r17
     12c:	b9 f7       	brne	.-18     	; 0x11c <main+0x76>
     12e:	c1 2c       	mov	r12, r1
     130:	d1 2c       	mov	r13, r1
     132:	76 01       	movw	r14, r12
		}
		
		for(i=0; i<br_uzoraka; i++)
		{
			
			AVG_mereni_napon += niz_mereni_napon[i];
     134:	81 91       	ld	r24, Z+
     136:	91 91       	ld	r25, Z+
     138:	c8 0e       	add	r12, r24
     13a:	d9 1e       	adc	r13, r25
     13c:	e1 1c       	adc	r14, r1
     13e:	f1 1c       	adc	r15, r1
		{
			
			niz_mereni_napon[i] = mereni_napon;
		}
		
		for(i=0; i<br_uzoraka; i++)
     140:	e0 17       	cp	r30, r16
     142:	f1 07       	cpc	r31, r17
     144:	b9 f7       	brne	.-18     	; 0x134 <main+0x8e>
		}
	
		AVG_mereni_napon = AVG_mereni_napon/br_uzoraka;
		
		
		if(flag_prekid_10ms == 1)		//slanje putem UART Tx na svakih 10ms. Podesava se u tajmer.c fajlu
     146:	80 91 db 01 	lds	r24, 0x01DB	; 0x8001db <flag_prekid_10ms>
     14a:	81 30       	cpi	r24, 0x01	; 1
     14c:	21 f7       	brne	.-56     	; 0x116 <main+0x70>
		{
			flag_prekid_10ms = 0;
     14e:	10 92 db 01 	sts	0x01DB, r1	; 0x8001db <flag_prekid_10ms>
		/*
		send_str("");
		itoa( struja_shunt_AVG , bafer, 10);
		send_str(bafer);
		*/
		send_str("  ");
     152:	89 e1       	ldi	r24, 0x19	; 25
     154:	91 e0       	ldi	r25, 0x01	; 1
     156:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		itoa( ref_napon_sa_pot , bafer, 10);
     15a:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <ref_napon_sa_pot>
     15e:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <ref_napon_sa_pot+0x1>
     162:	4a e0       	ldi	r20, 0x0A	; 10
     164:	be 01       	movw	r22, r28
     166:	6f 5f       	subi	r22, 0xFF	; 255
     168:	7f 4f       	sbci	r23, 0xFF	; 255
     16a:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		send_str(bafer);
     16e:	ce 01       	movw	r24, r28
     170:	01 96       	adiw	r24, 0x01	; 1
     172:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		
		
		
		send_str("  ");
     176:	89 e1       	ldi	r24, 0x19	; 25
     178:	91 e0       	ldi	r25, 0x01	; 1
     17a:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
     17e:	c7 01       	movw	r24, r14
     180:	b6 01       	movw	r22, r12
     182:	a5 01       	movw	r20, r10
     184:	94 01       	movw	r18, r8
     186:	0e 94 42 08 	call	0x1084	; 0x1084 <__udivmodsi4>
     18a:	da 01       	movw	r26, r20
     18c:	c9 01       	movw	r24, r18
     18e:	4a e0       	ldi	r20, 0x0A	; 10
     190:	be 01       	movw	r22, r28
     192:	6f 5f       	subi	r22, 0xFF	; 255
     194:	7f 4f       	sbci	r23, 0xFF	; 255
     196:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		itoa( AVG_mereni_napon , bafer, 10);
		send_str(bafer);
     19a:	ce 01       	movw	r24, r28
     19c:	01 96       	adiw	r24, 0x01	; 1
     19e:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		lcd1602_goto_xy(0,0);
     1a2:	60 e0       	ldi	r22, 0x00	; 0
     1a4:	70 e0       	ldi	r23, 0x00	; 0
     1a6:	80 e0       	ldi	r24, 0x00	; 0
     1a8:	90 e0       	ldi	r25, 0x00	; 0
     1aa:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
		lcd1602_send_string("     ");
     1ae:	86 e1       	ldi	r24, 0x16	; 22
     1b0:	91 e0       	ldi	r25, 0x01	; 1
     1b2:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
		lcd1602_goto_xy(0,0);
     1b6:	60 e0       	ldi	r22, 0x00	; 0
     1b8:	70 e0       	ldi	r23, 0x00	; 0
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
		lcd1602_send_string(bafer);
     1c2:	ce 01       	movw	r24, r28
     1c4:	01 96       	adiw	r24, 0x01	; 1
     1c6:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
		
		
		send_str("  ");
     1ca:	89 e1       	ldi	r24, 0x19	; 25
     1cc:	91 e0       	ldi	r25, 0x01	; 1
     1ce:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		itoa( merena_struja , bafer, 10);
     1d2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <merena_struja>
     1d6:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <merena_struja+0x1>
     1da:	4a e0       	ldi	r20, 0x0A	; 10
     1dc:	be 01       	movw	r22, r28
     1de:	6f 5f       	subi	r22, 0xFF	; 255
     1e0:	7f 4f       	sbci	r23, 0xFF	; 255
     1e2:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		send_str(bafer);
     1e6:	ce 01       	movw	r24, r28
     1e8:	01 96       	adiw	r24, 0x01	; 1
     1ea:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		lcd1602_goto_xy(0,1);
     1ee:	61 e0       	ldi	r22, 0x01	; 1
     1f0:	70 e0       	ldi	r23, 0x00	; 0
     1f2:	80 e0       	ldi	r24, 0x00	; 0
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
		lcd1602_send_string("     ");
     1fa:	86 e1       	ldi	r24, 0x16	; 22
     1fc:	91 e0       	ldi	r25, 0x01	; 1
     1fe:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
		lcd1602_goto_xy(0,1);
     202:	61 e0       	ldi	r22, 0x01	; 1
     204:	70 e0       	ldi	r23, 0x00	; 0
     206:	80 e0       	ldi	r24, 0x00	; 0
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 38 04 	call	0x870	; 0x870 <lcd1602_goto_xy>
		lcd1602_send_string(bafer);
     20e:	ce 01       	movw	r24, r28
     210:	01 96       	adiw	r24, 0x01	; 1
     212:	0e 94 41 04 	call	0x882	; 0x882 <lcd1602_send_string>
		itoa( suma_greske/100 , bafer, 10);
		send_str(bafer);
		*/
		
		
		send_str("  ");
     216:	89 e1       	ldi	r24, 0x19	; 25
     218:	91 e0       	ldi	r25, 0x01	; 1
     21a:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		itoa( Upravljanje*10 , bafer, 10);
     21e:	20 91 d9 01 	lds	r18, 0x01D9	; 0x8001d9 <Upravljanje>
     222:	30 91 da 01 	lds	r19, 0x01DA	; 0x8001da <Upravljanje+0x1>
     226:	c9 01       	movw	r24, r18
     228:	88 0f       	add	r24, r24
     22a:	99 1f       	adc	r25, r25
     22c:	22 0f       	add	r18, r18
     22e:	33 1f       	adc	r19, r19
     230:	22 0f       	add	r18, r18
     232:	33 1f       	adc	r19, r19
     234:	22 0f       	add	r18, r18
     236:	33 1f       	adc	r19, r19
     238:	4a e0       	ldi	r20, 0x0A	; 10
     23a:	be 01       	movw	r22, r28
     23c:	6f 5f       	subi	r22, 0xFF	; 255
     23e:	7f 4f       	sbci	r23, 0xFF	; 255
     240:	82 0f       	add	r24, r18
     242:	93 1f       	adc	r25, r19
     244:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		send_str(bafer);
     248:	ce 01       	movw	r24, r28
     24a:	01 96       	adiw	r24, 0x01	; 1
     24c:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		
		send_str("  ");
     250:	89 e1       	ldi	r24, 0x19	; 25
     252:	91 e0       	ldi	r25, 0x01	; 1
     254:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
     258:	4a e0       	ldi	r20, 0x0A	; 10
     25a:	be 01       	movw	r22, r28
     25c:	6f 5f       	subi	r22, 0xFF	; 255
     25e:	7f 4f       	sbci	r23, 0xFF	; 255
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		itoa( 0 , bafer, 10);
		send_str(bafer);
     268:	ce 01       	movw	r24, r28
     26a:	01 96       	adiw	r24, 0x01	; 1
     26c:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		
		send_str("  ");
     270:	89 e1       	ldi	r24, 0x19	; 25
     272:	91 e0       	ldi	r25, 0x01	; 1
     274:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
     278:	4a e0       	ldi	r20, 0x0A	; 10
     27a:	be 01       	movw	r22, r28
     27c:	6f 5f       	subi	r22, 0xFF	; 255
     27e:	7f 4f       	sbci	r23, 0xFF	; 255
     280:	88 e2       	ldi	r24, 0x28	; 40
     282:	93 e2       	ldi	r25, 0x23	; 35
     284:	0e 94 87 08 	call	0x110e	; 0x110e <__itoa_ncheck>
		itoa( 9000 , bafer, 10);
		send_str(bafer);
     288:	ce 01       	movw	r24, r28
     28a:	01 96       	adiw	r24, 0x01	; 1
     28c:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
		itoa( 20000 , bafer, 10);
		send_str(bafer);
		*/

		
		send_str("\n");
     290:	8c e1       	ldi	r24, 0x1C	; 28
     292:	91 e0       	ldi	r25, 0x01	; 1
     294:	0e 94 7d 06 	call	0xcfa	; 0xcfa <send_str>
     298:	3e cf       	rjmp	.-388    	; 0x116 <main+0x70>

0000029a <ADC_init>:
volatile void sumator();
volatile void _2x8bit_reg_2_1x16bit_reg();

void ADC_init()
{
	DDRD |= 1<<DDB7;
     29a:	57 9a       	sbi	0x0a, 7	; 10
	
	PRR = 0;						//power reduction off
     29c:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
	
	ADMUX = 0b11000000;		        //ref internal 1.1V, kanal A0
     2a0:	80 ec       	ldi	r24, 0xC0	; 192
     2a2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = 0b11101110;			//ADC enable, start conversion, auto trigger enable, ADC conv. complete interrupt enable, 64 prescaler = 250kHz, a preporuka je do 200kHz
     2a6:	8e ee       	ldi	r24, 0xEE	; 238
     2a8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	ADCSRB = 0b0;					//0b11
     2ac:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	ad_kanal = 0; //prvo citam A0
     2b0:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <ad_kanal>
     2b4:	08 95       	ret

000002b6 <sumator>:
}



volatile void sumator()
{
     2b6:	cf 92       	push	r12
     2b8:	df 92       	push	r13
     2ba:	ef 92       	push	r14
     2bc:	ff 92       	push	r15
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
	//radi sumu po kolonama matrice, tj po kanalu, izvlaci prosek i upisuje u odgovarajucu promenljivu
	volatile static uint8_t i=0;


	
	if (ad_kanal == 0) //ref_napon_sa_pot
     2c2:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     2c6:	81 11       	cpse	r24, r1
     2c8:	4d c0       	rjmp	.+154    	; 0x364 <sumator+0xae>
	{
		ref_napon_sa_pot = 0; //nuliram da ne bi uticalo na sumiranje i prosek i stvarne vrednosti
     2ca:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ref_napon_sa_pot+0x1>
     2ce:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <ref_napon_sa_pot>
		
		for (i=0; i<BR_SEMPLOVA; i++)
     2d2:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <__data_end>
     2d6:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     2da:	84 31       	cpi	r24, 0x14	; 20
     2dc:	18 f5       	brcc	.+70     	; 0x324 <sumator+0x6e>
		{
			ref_napon_sa_pot += adc_res[ad_kanal][i];		//suma po nultoj koloni (nultom kanalu)
     2de:	44 e1       	ldi	r20, 0x14	; 20
     2e0:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <ad_kanal>
     2e4:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     2e8:	4e 9f       	mul	r20, r30
     2ea:	f0 01       	movw	r30, r0
     2ec:	11 24       	eor	r1, r1
     2ee:	e8 0f       	add	r30, r24
     2f0:	f1 1d       	adc	r31, r1
     2f2:	ee 0f       	add	r30, r30
     2f4:	ff 1f       	adc	r31, r31
     2f6:	e9 5d       	subi	r30, 0xD9	; 217
     2f8:	fe 4f       	sbci	r31, 0xFE	; 254
     2fa:	20 81       	ld	r18, Z
     2fc:	31 81       	ldd	r19, Z+1	; 0x01
     2fe:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <ref_napon_sa_pot>
     302:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <ref_napon_sa_pot+0x1>
     306:	82 0f       	add	r24, r18
     308:	93 1f       	adc	r25, r19
     30a:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <ref_napon_sa_pot+0x1>
     30e:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <ref_napon_sa_pot>
	
	if (ad_kanal == 0) //ref_napon_sa_pot
	{
		ref_napon_sa_pot = 0; //nuliram da ne bi uticalo na sumiranje i prosek i stvarne vrednosti
		
		for (i=0; i<BR_SEMPLOVA; i++)
     312:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     316:	8f 5f       	subi	r24, 0xFF	; 255
     318:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
     31c:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     320:	84 31       	cpi	r24, 0x14	; 20
     322:	f0 f2       	brcs	.-68     	; 0x2e0 <sumator+0x2a>
		{
			ref_napon_sa_pot += adc_res[ad_kanal][i];		//suma po nultoj koloni (nultom kanalu)
		}
		ref_napon_sa_pot = (ref_napon_sa_pot/BR_SEMPLOVA) * 19.613;  //1023 = 20000 mV
     324:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <ref_napon_sa_pot>
     328:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <ref_napon_sa_pot+0x1>
     32c:	ad ec       	ldi	r26, 0xCD	; 205
     32e:	bc ec       	ldi	r27, 0xCC	; 204
     330:	0e 94 64 08 	call	0x10c8	; 0x10c8 <__umulhisi3>
     334:	92 95       	swap	r25
     336:	82 95       	swap	r24
     338:	8f 70       	andi	r24, 0x0F	; 15
     33a:	89 27       	eor	r24, r25
     33c:	9f 70       	andi	r25, 0x0F	; 15
     33e:	89 27       	eor	r24, r25
     340:	bc 01       	movw	r22, r24
     342:	80 e0       	ldi	r24, 0x00	; 0
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	0e 94 33 07 	call	0xe66	; 0xe66 <__floatunsisf>
     34a:	2d e6       	ldi	r18, 0x6D	; 109
     34c:	37 ee       	ldi	r19, 0xE7	; 231
     34e:	4c e9       	ldi	r20, 0x9C	; 156
     350:	51 e4       	ldi	r21, 0x41	; 65
     352:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     356:	0e 94 04 07 	call	0xe08	; 0xe08 <__fixunssfsi>
     35a:	70 93 25 01 	sts	0x0125, r23	; 0x800125 <ref_napon_sa_pot+0x1>
     35e:	60 93 24 01 	sts	0x0124, r22	; 0x800124 <ref_napon_sa_pot>
     362:	b5 c0       	rjmp	.+362    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
		
		//ref_napon_sa_pot = 9000; //za potrebe debagovanja
	}
	else if (ad_kanal == 1)	//merena struja
     364:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     368:	81 30       	cpi	r24, 0x01	; 1
     36a:	09 f0       	breq	.+2      	; 0x36e <sumator+0xb8>
     36c:	4d c0       	rjmp	.+154    	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
	{
		merena_struja = 0;
     36e:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <merena_struja+0x1>
     372:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <merena_struja>
		
		for (i=0; i<BR_SEMPLOVA; i++)
     376:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <__data_end>
     37a:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     37e:	84 31       	cpi	r24, 0x14	; 20
     380:	18 f5       	brcc	.+70     	; 0x3c8 <sumator+0x112>
		{
			merena_struja += adc_res[ad_kanal][i];
     382:	44 e1       	ldi	r20, 0x14	; 20
     384:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <ad_kanal>
     388:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     38c:	4e 9f       	mul	r20, r30
     38e:	f0 01       	movw	r30, r0
     390:	11 24       	eor	r1, r1
     392:	e8 0f       	add	r30, r24
     394:	f1 1d       	adc	r31, r1
     396:	ee 0f       	add	r30, r30
     398:	ff 1f       	adc	r31, r31
     39a:	e9 5d       	subi	r30, 0xD9	; 217
     39c:	fe 4f       	sbci	r31, 0xFE	; 254
     39e:	20 81       	ld	r18, Z
     3a0:	31 81       	ldd	r19, Z+1	; 0x01
     3a2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <merena_struja>
     3a6:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <merena_struja+0x1>
     3aa:	82 0f       	add	r24, r18
     3ac:	93 1f       	adc	r25, r19
     3ae:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <merena_struja+0x1>
     3b2:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <merena_struja>
	}
	else if (ad_kanal == 1)	//merena struja
	{
		merena_struja = 0;
		
		for (i=0; i<BR_SEMPLOVA; i++)
     3b6:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     3ba:	8f 5f       	subi	r24, 0xFF	; 255
     3bc:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
     3c0:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     3c4:	84 31       	cpi	r24, 0x14	; 20
     3c6:	f0 f2       	brcs	.-68     	; 0x384 <sumator+0xce>
		{
			merena_struja += adc_res[ad_kanal][i];
		}
		merena_struja = (merena_struja/BR_SEMPLOVA) * 4.895;  // 1023 = 1093 mV, R=220 mOhm, I=V/R = 4968 mA (MAX); izracunato i skalirano da se za max input dobija ~5A
     3c8:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <merena_struja>
     3cc:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <merena_struja+0x1>
     3d0:	ad ec       	ldi	r26, 0xCD	; 205
     3d2:	bc ec       	ldi	r27, 0xCC	; 204
     3d4:	0e 94 64 08 	call	0x10c8	; 0x10c8 <__umulhisi3>
     3d8:	92 95       	swap	r25
     3da:	82 95       	swap	r24
     3dc:	8f 70       	andi	r24, 0x0F	; 15
     3de:	89 27       	eor	r24, r25
     3e0:	9f 70       	andi	r25, 0x0F	; 15
     3e2:	89 27       	eor	r24, r25
     3e4:	bc 01       	movw	r22, r24
     3e6:	80 e0       	ldi	r24, 0x00	; 0
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	0e 94 33 07 	call	0xe66	; 0xe66 <__floatunsisf>
     3ee:	27 ed       	ldi	r18, 0xD7	; 215
     3f0:	33 ea       	ldi	r19, 0xA3	; 163
     3f2:	4c e9       	ldi	r20, 0x9C	; 156
     3f4:	50 e4       	ldi	r21, 0x40	; 64
     3f6:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     3fa:	0e 94 04 07 	call	0xe08	; 0xe08 <__fixunssfsi>
     3fe:	70 93 23 01 	sts	0x0123, r23	; 0x800123 <merena_struja+0x1>
     402:	60 93 22 01 	sts	0x0122, r22	; 0x800122 <merena_struja>
     406:	63 c0       	rjmp	.+198    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
															  //malo je kompenzovan mnozitelj merenjem pomocu voltmetra
															 /***** Vref 1.1V je zapravo 1.093 V ******/
	}
	else if (ad_kanal == 2)	//mereni napon
     408:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     40c:	82 30       	cpi	r24, 0x02	; 2
     40e:	09 f0       	breq	.+2      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     410:	5e c0       	rjmp	.+188    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
	{
		mereni_napon = 0;
     412:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <mereni_napon+0x1>
     416:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <mereni_napon>
		
		for (i=0; i<BR_SEMPLOVA; i++)
     41a:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <__data_end>
     41e:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     422:	84 31       	cpi	r24, 0x14	; 20
     424:	18 f5       	brcc	.+70     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
		{
			mereni_napon += adc_res[ad_kanal][i];
     426:	44 e1       	ldi	r20, 0x14	; 20
     428:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <ad_kanal>
     42c:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     430:	4e 9f       	mul	r20, r30
     432:	f0 01       	movw	r30, r0
     434:	11 24       	eor	r1, r1
     436:	e8 0f       	add	r30, r24
     438:	f1 1d       	adc	r31, r1
     43a:	ee 0f       	add	r30, r30
     43c:	ff 1f       	adc	r31, r31
     43e:	e9 5d       	subi	r30, 0xD9	; 217
     440:	fe 4f       	sbci	r31, 0xFE	; 254
     442:	80 81       	ld	r24, Z
     444:	91 81       	ldd	r25, Z+1	; 0x01
     446:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <mereni_napon>
     44a:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <mereni_napon+0x1>
     44e:	82 0f       	add	r24, r18
     450:	93 1f       	adc	r25, r19
     452:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <mereni_napon+0x1>
     456:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <mereni_napon>
	}
	else if (ad_kanal == 2)	//mereni napon
	{
		mereni_napon = 0;
		
		for (i=0; i<BR_SEMPLOVA; i++)
     45a:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     45e:	8f 5f       	subi	r24, 0xFF	; 255
     460:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
     464:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     468:	84 31       	cpi	r24, 0x14	; 20
     46a:	f0 f2       	brcs	.-68     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
		{
			mereni_napon += adc_res[ad_kanal][i];
		}
		mereni_napon = ((mereni_napon/BR_SEMPLOVA) * 19.613) - (merena_struja * 0.22);  //1023 = 20000 mV - naposnki pad preko sant otpornika (220 mOhm)
     46c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <mereni_napon>
     470:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <mereni_napon+0x1>
     474:	c0 91 22 01 	lds	r28, 0x0122	; 0x800122 <merena_struja>
     478:	d0 91 23 01 	lds	r29, 0x0123	; 0x800123 <merena_struja+0x1>
     47c:	64 e1       	ldi	r22, 0x14	; 20
     47e:	70 e0       	ldi	r23, 0x00	; 0
     480:	0e 94 2e 08 	call	0x105c	; 0x105c <__divmodhi4>
     484:	07 2e       	mov	r0, r23
     486:	00 0c       	add	r0, r0
     488:	88 0b       	sbc	r24, r24
     48a:	99 0b       	sbc	r25, r25
     48c:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     490:	2d e6       	ldi	r18, 0x6D	; 109
     492:	37 ee       	ldi	r19, 0xE7	; 231
     494:	4c e9       	ldi	r20, 0x9C	; 156
     496:	51 e4       	ldi	r21, 0x41	; 65
     498:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     49c:	6b 01       	movw	r12, r22
     49e:	7c 01       	movw	r14, r24
     4a0:	be 01       	movw	r22, r28
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	0e 94 33 07 	call	0xe66	; 0xe66 <__floatunsisf>
     4aa:	2e ea       	ldi	r18, 0xAE	; 174
     4ac:	37 e4       	ldi	r19, 0x47	; 71
     4ae:	41 e6       	ldi	r20, 0x61	; 97
     4b0:	5e e3       	ldi	r21, 0x3E	; 62
     4b2:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     4b6:	9b 01       	movw	r18, r22
     4b8:	ac 01       	movw	r20, r24
     4ba:	c7 01       	movw	r24, r14
     4bc:	b6 01       	movw	r22, r12
     4be:	0e 94 90 06 	call	0xd20	; 0xd20 <__subsf3>
     4c2:	0e 94 fd 06 	call	0xdfa	; 0xdfa <__fixsfsi>
     4c6:	70 93 21 01 	sts	0x0121, r23	; 0x800121 <mereni_napon+0x1>
     4ca:	60 93 20 01 	sts	0x0120, r22	; 0x800120 <mereni_napon>
																				//na buck, ili pak zbog ne bas real time podataka sa ad ulaza jer im uzimam prosek
																				//Svakako trebam ovo jos malo razmotriti
	}


}
     4ce:	df 91       	pop	r29
     4d0:	cf 91       	pop	r28
     4d2:	ff 90       	pop	r15
     4d4:	ef 90       	pop	r14
     4d6:	df 90       	pop	r13
     4d8:	cf 90       	pop	r12
     4da:	08 95       	ret

000004dc <_2x8bit_reg_2_1x16bit_reg>:
		//adc_res[ad_kanal][brojac_sempla] = 512 + adc_low;	//256*2
	//else if(adc_high==3)
		//adc_res[ad_kanal][brojac_sempla] = 768 + adc_low;	//256*3
	
	
	adc_res[ad_kanal][brojac_sempla] = (uint16_t)ADC;	//LOL. skontao sam da 'postoji' vec ovaj 16-bit registar, tj da je resen problem
     4dc:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <ad_kanal>
     4e0:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <brojac_sempla>
     4e4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     4e8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     4ec:	34 e1       	ldi	r19, 0x14	; 20
     4ee:	e3 9f       	mul	r30, r19
     4f0:	f0 01       	movw	r30, r0
     4f2:	11 24       	eor	r1, r1
     4f4:	e2 0f       	add	r30, r18
     4f6:	f1 1d       	adc	r31, r1
     4f8:	ee 0f       	add	r30, r30
     4fa:	ff 1f       	adc	r31, r31
     4fc:	e9 5d       	subi	r30, 0xD9	; 217
     4fe:	fe 4f       	sbci	r31, 0xFE	; 254
     500:	91 83       	std	Z+1, r25	; 0x01
     502:	80 83       	st	Z, r24
     504:	08 95       	ret

00000506 <__vector_21>:
	ad_kanal = 0; //prvo citam A0
	
}

ISR(ADC_vect)
{
     506:	1f 92       	push	r1
     508:	0f 92       	push	r0
     50a:	0f b6       	in	r0, 0x3f	; 63
     50c:	0f 92       	push	r0
     50e:	11 24       	eor	r1, r1
     510:	2f 93       	push	r18
     512:	3f 93       	push	r19
     514:	4f 93       	push	r20
     516:	5f 93       	push	r21
     518:	6f 93       	push	r22
     51a:	7f 93       	push	r23
     51c:	8f 93       	push	r24
     51e:	9f 93       	push	r25
     520:	af 93       	push	r26
     522:	bf 93       	push	r27
     524:	ef 93       	push	r30
     526:	ff 93       	push	r31
	/*
	AD konverzija
	ISR okine kada je gotova konverzija
	*/
	PORTD |= 1<<7;       //togle za osciloskop
     528:	5f 9a       	sbi	0x0b, 7	; 11
	
	_2x8bit_reg_2_1x16bit_reg();   //upis adc rezultata u matricu; Trajanje ovog dela: ~2us
     52a:	0e 94 6e 02 	call	0x4dc	; 0x4dc <_2x8bit_reg_2_1x16bit_reg>

	

	
	if (ad_kanal==0)
     52e:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     532:	81 11       	cpse	r24, r1
     534:	03 c0       	rjmp	.+6      	; 0x53c <__vector_21+0x36>
			sumator();      //suma za dati kanal i izvucen prosek i upisan u odg promenljivu
     536:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <sumator>
     53a:	0d c0       	rjmp	.+26     	; 0x556 <__vector_21+0x50>
	else if (ad_kanal==1)		
     53c:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     540:	81 30       	cpi	r24, 0x01	; 1
     542:	19 f4       	brne	.+6      	; 0x54a <__vector_21+0x44>
			sumator();
     544:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <sumator>
     548:	06 c0       	rjmp	.+12     	; 0x556 <__vector_21+0x50>
	else if (ad_kanal==2)
     54a:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     54e:	82 30       	cpi	r24, 0x02	; 2
     550:	11 f4       	brne	.+4      	; 0x556 <__vector_21+0x50>
			sumator();
     552:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <sumator>
	//OCR1A = ref_napon_sa_pot * 20.0;  //top = 400
	//OCR1A = 200;

	
	
	ADCSRA &= ~(1<<ADEN);	//iskljucim adc da bi promena u ADMUX bila sigurna, po preporuci iz datasheet-a
     556:	ea e7       	ldi	r30, 0x7A	; 122
     558:	f0 e0       	ldi	r31, 0x00	; 0
     55a:	80 81       	ld	r24, Z
     55c:	8f 77       	andi	r24, 0x7F	; 127
     55e:	80 83       	st	Z, r24
	
	
	ad_kanal++;			//inkrementiraj kanal
     560:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     564:	8f 5f       	subi	r24, 0xFF	; 255
     566:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <ad_kanal>
	if(ad_kanal > 2)	//kreni opet od nule kad dodjes do poslednjeg; 2, da citam samo prva tri
     56a:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     56e:	83 30       	cpi	r24, 0x03	; 3
     570:	68 f0       	brcs	.+26     	; 0x58c <__vector_21+0x86>
	{
		ad_kanal = 0;
     572:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <ad_kanal>
		
		brojac_sempla++; //kad dodjes do kraja kanala predji na sledeci red semplova
     576:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <brojac_sempla>
     57a:	8f 5f       	subi	r24, 0xFF	; 255
     57c:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <brojac_sempla>
		if(brojac_sempla >= BR_SEMPLOVA) //kad dodjes do kraja kreni opet od nule
     580:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <brojac_sempla>
     584:	84 31       	cpi	r24, 0x14	; 20
     586:	10 f0       	brcs	.+4      	; 0x58c <__vector_21+0x86>
			brojac_sempla = 0;
     588:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <brojac_sempla>
	
	
	
	
	//multipleksiranje ad ulaza; tj. promena ad kanala
	switch(ad_kanal)
     58c:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <ad_kanal>
     590:	81 30       	cpi	r24, 0x01	; 1
     592:	61 f0       	breq	.+24     	; 0x5ac <__vector_21+0xa6>
     594:	28 f0       	brcs	.+10     	; 0x5a0 <__vector_21+0x9a>
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	91 f0       	breq	.+36     	; 0x5be <__vector_21+0xb8>
     59a:	83 30       	cpi	r24, 0x03	; 3
     59c:	c9 f0       	breq	.+50     	; 0x5d0 <__vector_21+0xca>
     59e:	1d c0       	rjmp	.+58     	; 0x5da <__vector_21+0xd4>
	{
		case 0:
				ADMUX &= ~(0b11);		//00;ref internal 1.1V, kanal A0
     5a0:	ec e7       	ldi	r30, 0x7C	; 124
     5a2:	f0 e0       	ldi	r31, 0x00	; 0
     5a4:	80 81       	ld	r24, Z
     5a6:	8c 7f       	andi	r24, 0xFC	; 252
     5a8:	80 83       	st	Z, r24
		break;
     5aa:	17 c0       	rjmp	.+46     	; 0x5da <__vector_21+0xd4>
		
		case 1:
				ADMUX &= ~(0b10);		//01;ref internal 1.1V, kanal A1
     5ac:	ec e7       	ldi	r30, 0x7C	; 124
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	80 81       	ld	r24, Z
     5b2:	8d 7f       	andi	r24, 0xFD	; 253
     5b4:	80 83       	st	Z, r24
				ADMUX |= (0b1);
     5b6:	80 81       	ld	r24, Z
     5b8:	81 60       	ori	r24, 0x01	; 1
     5ba:	80 83       	st	Z, r24
		break;
     5bc:	0e c0       	rjmp	.+28     	; 0x5da <__vector_21+0xd4>
		
		case 2:
				ADMUX &= ~(0b1);		//10;ref internal 1.1V, kanal A2
     5be:	ec e7       	ldi	r30, 0x7C	; 124
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	80 81       	ld	r24, Z
     5c4:	8e 7f       	andi	r24, 0xFE	; 254
     5c6:	80 83       	st	Z, r24
				ADMUX |= (0b10);
     5c8:	80 81       	ld	r24, Z
     5ca:	82 60       	ori	r24, 0x02	; 2
     5cc:	80 83       	st	Z, r24
		break;
     5ce:	05 c0       	rjmp	.+10     	; 0x5da <__vector_21+0xd4>
		
		case 3:
				ADMUX |= (0b11);		//11;ref internal 1.1V, kanal A3
     5d0:	ec e7       	ldi	r30, 0x7C	; 124
     5d2:	f0 e0       	ldi	r31, 0x00	; 0
     5d4:	80 81       	ld	r24, Z
     5d6:	83 60       	ori	r24, 0x03	; 3
     5d8:	80 83       	st	Z, r24
	}
	
	
	//napomena: promena ulaza se vrsi ovde, a kad naredni put uleti u ISR vrsi se konverzija tog kanala. 
	
	ADCSRA |= (1<<ADEN)|(1<<ADSC);	//ponovo dozvolim adc posle promene u ADMUX i pokrenem opet prvu konverziju da bi htelo da radi u Free running
     5da:	ea e7       	ldi	r30, 0x7A	; 122
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	80 81       	ld	r24, Z
     5e0:	80 6c       	ori	r24, 0xC0	; 192
     5e2:	80 83       	st	Z, r24
	
	
	
	//trajanje dela sa multipleksiranjem: ~ 1.7 us

	PORTD &= ~(1<<7);       //togle za osciloskop
     5e4:	5f 98       	cbi	0x0b, 7	; 11
}
     5e6:	ff 91       	pop	r31
     5e8:	ef 91       	pop	r30
     5ea:	bf 91       	pop	r27
     5ec:	af 91       	pop	r26
     5ee:	9f 91       	pop	r25
     5f0:	8f 91       	pop	r24
     5f2:	7f 91       	pop	r23
     5f4:	6f 91       	pop	r22
     5f6:	5f 91       	pop	r21
     5f8:	4f 91       	pop	r20
     5fa:	3f 91       	pop	r19
     5fc:	2f 91       	pop	r18
     5fe:	0f 90       	pop	r0
     600:	0f be       	out	0x3f, r0	; 63
     602:	0f 90       	pop	r0
     604:	1f 90       	pop	r1
     606:	18 95       	reti

00000608 <__vector_1>:
	
	
}

ISR(INT0_vect)
{
     608:	1f 92       	push	r1
     60a:	0f 92       	push	r0
     60c:	0f b6       	in	r0, 0x3f	; 63
     60e:	0f 92       	push	r0
     610:	11 24       	eor	r1, r1
     612:	2f 93       	push	r18
     614:	8f 93       	push	r24
     616:	9f 93       	push	r25
	
		//interapt opali na rastucu ivicu INT0; ovo sam uradio zbog velike rezolucije enkodera -1024 * 57.5 na izlazu, tj na tocku zbog 2 reduktora
	
	brojac_ext_interaptova++;
     618:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <brojac_ext_interaptova>
     61c:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <brojac_ext_interaptova+0x1>
     620:	01 96       	adiw	r24, 0x01	; 1
     622:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <brojac_ext_interaptova+0x1>
     626:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <brojac_ext_interaptova>
	

	
		if ( PIND & (1<<PORTD3) )	//smer 1; proverava se logicki nivo drugog kanala
     62a:	4b 9b       	sbis	0x09, 3	; 9
     62c:	0d c0       	rjmp	.+26     	; 0x648 <__vector_1+0x40>
		{
			smer_obrtanja = 1;
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <smer_obrtanja>
			impulsi++;
     634:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <impulsi>
     638:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <impulsi+0x1>
     63c:	01 96       	adiw	r24, 0x01	; 1
     63e:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <impulsi+0x1>
     642:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <impulsi>
     646:	0c c0       	rjmp	.+24     	; 0x660 <__vector_1+0x58>
		} 
		else								//smer 2
		{
			smer_obrtanja = 2;
     648:	82 e0       	ldi	r24, 0x02	; 2
     64a:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <smer_obrtanja>
			impulsi--;	
     64e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <impulsi>
     652:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <impulsi+0x1>
     656:	01 97       	sbiw	r24, 0x01	; 1
     658:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <impulsi+0x1>
     65c:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <impulsi>
	
	
	
	
	
	if(impulsi > 58879)		//za apsolutno merenje ugla
     660:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <impulsi>
     664:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <impulsi+0x1>
     668:	81 15       	cp	r24, r1
     66a:	96 4e       	sbci	r25, 0xE6	; 230
     66c:	28 f0       	brcs	.+10     	; 0x678 <__vector_1+0x70>
		impulsi = 0;
     66e:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <impulsi+0x1>
     672:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <impulsi>
     676:	04 c0       	rjmp	.+8      	; 0x680 <__vector_1+0x78>
	else if(impulsi < 0 )
     678:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <impulsi>
     67c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <impulsi+0x1>
	//problem se javlja kada ove impulse zelim da iskoristim za merenje brzine, a pri prelazu preko granicne vrednosti sa 58879 na 0 i obrnuto
	//zato sam ubacio jos jedan brojac koji broji prekide "brojac_ext_interaptova" relativno, a ne apsolutno
		
	//ugao = impulsi / 57.5;	//skaliranje, 58879 impulsa po krugu odgovara 360 stepeni tocka; !!!atmega se ovde zaglavi pri umerenoj frekvenciji prekida!!!
	//ugao = 100;
}
     680:	9f 91       	pop	r25
     682:	8f 91       	pop	r24
     684:	2f 91       	pop	r18
     686:	0f 90       	pop	r0
     688:	0f be       	out	0x3f, r0	; 63
     68a:	0f 90       	pop	r0
     68c:	1f 90       	pop	r1
     68e:	18 95       	reti

00000690 <i2c_init>:
    while ((TWCR & (1 << TWINT)) == 0);
}

void i2c_stop_condition(void)
{
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
     690:	80 e1       	ldi	r24, 0x10	; 16
     692:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
     696:	08 95       	ret

00000698 <i2c_start_condition>:
     698:	84 ea       	ldi	r24, 0xA4	; 164
     69a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     69e:	ec eb       	ldi	r30, 0xBC	; 188
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	80 81       	ld	r24, Z
     6a4:	88 23       	and	r24, r24
     6a6:	ec f7       	brge	.-6      	; 0x6a2 <i2c_start_condition+0xa>
     6a8:	08 95       	ret

000006aa <i2c_send_byte>:
}

void i2c_send_byte(unsigned char byte)
{
	TWDR = byte;
     6aa:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = (1 << TWINT) | (1 << TWEN);
     6ae:	84 e8       	ldi	r24, 0x84	; 132
     6b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while ((TWCR & (1 << TWINT)) == 0);
     6b4:	ec eb       	ldi	r30, 0xBC	; 188
     6b6:	f0 e0       	ldi	r31, 0x00	; 0
     6b8:	80 81       	ld	r24, Z
     6ba:	88 23       	and	r24, r24
     6bc:	ec f7       	brge	.-6      	; 0x6b8 <i2c_send_byte+0xe>
}
     6be:	08 95       	ret

000006c0 <i2c_send_packet>:

void i2c_send_packet(unsigned char value, unsigned char address)
{
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	c8 2f       	mov	r28, r24
     6c6:	d6 2f       	mov	r29, r22
	i2c_start_condition();
     6c8:	0e 94 4c 03 	call	0x698	; 0x698 <i2c_start_condition>
	i2c_send_byte(address);
     6cc:	8d 2f       	mov	r24, r29
     6ce:	0e 94 55 03 	call	0x6aa	; 0x6aa <i2c_send_byte>
	i2c_send_byte(value);
     6d2:	8c 2f       	mov	r24, r28
     6d4:	0e 94 55 03 	call	0x6aa	; 0x6aa <i2c_send_byte>
    while ((TWCR & (1 << TWINT)) == 0);
}

void i2c_stop_condition(void)
{
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
     6d8:	84 e9       	ldi	r24, 0x94	; 148
     6da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
{
	i2c_start_condition();
	i2c_send_byte(address);
	i2c_send_byte(value);
	i2c_stop_condition();
}
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	08 95       	ret

000006e4 <putnibble>:
	uint8_t led_pin;
} lcd;


void putnibble(char t)
{
     6e4:	cf 93       	push	r28
     6e6:	c8 2f       	mov	r28, r24
	t <<= 4;
	i2c_send_packet(lcd.led_pin |= 0x04, SLA_W);
     6e8:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     6ec:	84 60       	ori	r24, 0x04	; 4
     6ee:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     6f2:	6e e4       	ldi	r22, 0x4E	; 78
     6f4:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6f8:	87 ec       	ldi	r24, 0xC7	; 199
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	01 97       	sbiw	r24, 0x01	; 1
     6fe:	f1 f7       	brne	.-4      	; 0x6fc <putnibble+0x18>
     700:	00 c0       	rjmp	.+0      	; 0x702 <putnibble+0x1e>
     702:	00 00       	nop
	_delay_us(50);
	i2c_send_packet(lcd.led_pin | t, SLA_W);
     704:	c2 95       	swap	r28
     706:	c0 7f       	andi	r28, 0xF0	; 240
     708:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     70c:	6e e4       	ldi	r22, 0x4E	; 78
     70e:	8c 2b       	or	r24, r28
     710:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
	i2c_send_packet(lcd.led_pin &= ~0x04, SLA_W);
     714:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     718:	8b 7f       	andi	r24, 0xFB	; 251
     71a:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     71e:	6e e4       	ldi	r22, 0x4E	; 78
     720:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
     724:	87 ec       	ldi	r24, 0xC7	; 199
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	01 97       	sbiw	r24, 0x01	; 1
     72a:	f1 f7       	brne	.-4      	; 0x728 <putnibble+0x44>
     72c:	00 c0       	rjmp	.+0      	; 0x72e <putnibble+0x4a>
     72e:	00 00       	nop
	_delay_us(50);
}
     730:	cf 91       	pop	r28
     732:	08 95       	ret

00000734 <lcd1602_send_byte>:

void lcd1602_send_byte(char c, char rs)
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	c8 2f       	mov	r28, r24
	char highc = 0;
	highc = c >> 4;
     73a:	d8 2f       	mov	r29, r24
     73c:	d2 95       	swap	r29
     73e:	df 70       	andi	r29, 0x0F	; 15
	if (rs == LCD_COMMAND)
     740:	61 11       	cpse	r22, r1
     742:	09 c0       	rjmp	.+18     	; 0x756 <lcd1602_send_byte+0x22>
		i2c_send_packet(lcd.led_pin &=~ 0x01, SLA_W);
     744:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     748:	8e 7f       	andi	r24, 0xFE	; 254
     74a:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     74e:	6e e4       	ldi	r22, 0x4E	; 78
     750:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
     754:	08 c0       	rjmp	.+16     	; 0x766 <lcd1602_send_byte+0x32>
	else
		i2c_send_packet(lcd.led_pin |= 0x01, SLA_W);
     756:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     75a:	81 60       	ori	r24, 0x01	; 1
     75c:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     760:	6e e4       	ldi	r22, 0x4E	; 78
     762:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
	putnibble(highc);
     766:	8d 2f       	mov	r24, r29
     768:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
	putnibble(c);
     76c:	8c 2f       	mov	r24, r28
     76e:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
}
     772:	df 91       	pop	r29
     774:	cf 91       	pop	r28
     776:	08 95       	ret

00000778 <lcd1602_send_char>:

void lcd1602_send_char(char c)
{
     778:	cf 93       	push	r28
     77a:	c8 2f       	mov	r28, r24
	char highc = 0;

	highc = c >> 4;
	i2c_send_packet (lcd.led_pin |= 0x01, SLA_W);
     77c:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     780:	81 60       	ori	r24, 0x01	; 1
     782:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     786:	6e e4       	ldi	r22, 0x4E	; 78
     788:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
	putnibble(highc);
     78c:	8c 2f       	mov	r24, r28
     78e:	82 95       	swap	r24
     790:	8f 70       	andi	r24, 0x0F	; 15
     792:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
	putnibble(c);
     796:	8c 2f       	mov	r24, r28
     798:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
}
     79c:	cf 91       	pop	r28
     79e:	08 95       	ret

000007a0 <lcd1602_init>:

void lcd1602_init()
{
	lcd.led_pin = 0;
     7a0:	10 92 cc 01 	sts	0x01CC, r1	; 0x8001cc <lcd>
	i2c_init();
     7a4:	0e 94 48 03 	call	0x690	; 0x690 <i2c_init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7a8:	8f e5       	ldi	r24, 0x5F	; 95
     7aa:	9a ee       	ldi	r25, 0xEA	; 234
     7ac:	01 97       	sbiw	r24, 0x01	; 1
     7ae:	f1 f7       	brne	.-4      	; 0x7ac <lcd1602_init+0xc>
     7b0:	00 c0       	rjmp	.+0      	; 0x7b2 <lcd1602_init+0x12>
     7b2:	00 00       	nop
	_delay_ms(15);
	putnibble(0b00000011);
     7b4:	83 e0       	ldi	r24, 0x03	; 3
     7b6:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
     7ba:	8f e7       	ldi	r24, 0x7F	; 127
     7bc:	9e e3       	ldi	r25, 0x3E	; 62
     7be:	01 97       	sbiw	r24, 0x01	; 1
     7c0:	f1 f7       	brne	.-4      	; 0x7be <lcd1602_init+0x1e>
     7c2:	00 c0       	rjmp	.+0      	; 0x7c4 <lcd1602_init+0x24>
     7c4:	00 00       	nop
	_delay_ms(4);
	putnibble(0b00000011);
     7c6:	83 e0       	ldi	r24, 0x03	; 3
     7c8:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7cc:	8f e8       	ldi	r24, 0x8F	; 143
     7ce:	91 e0       	ldi	r25, 0x01	; 1
     7d0:	01 97       	sbiw	r24, 0x01	; 1
     7d2:	f1 f7       	brne	.-4      	; 0x7d0 <lcd1602_init+0x30>
     7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <lcd1602_init+0x36>
     7d6:	00 00       	nop
	_delay_us(100);
	putnibble(0b00000011);
     7d8:	83 e0       	ldi	r24, 0x03	; 3
     7da:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7de:	8f e9       	ldi	r24, 0x9F	; 159
     7e0:	9f e0       	ldi	r25, 0x0F	; 15
     7e2:	01 97       	sbiw	r24, 0x01	; 1
     7e4:	f1 f7       	brne	.-4      	; 0x7e2 <lcd1602_init+0x42>
     7e6:	00 c0       	rjmp	.+0      	; 0x7e8 <lcd1602_init+0x48>
     7e8:	00 00       	nop
	_delay_ms(1);
	putnibble(0b00000010);
     7ea:	82 e0       	ldi	r24, 0x02	; 2
     7ec:	0e 94 72 03 	call	0x6e4	; 0x6e4 <putnibble>
     7f0:	8f e9       	ldi	r24, 0x9F	; 159
     7f2:	9f e0       	ldi	r25, 0x0F	; 15
     7f4:	01 97       	sbiw	r24, 0x01	; 1
     7f6:	f1 f7       	brne	.-4      	; 0x7f4 <lcd1602_init+0x54>
     7f8:	00 c0       	rjmp	.+0      	; 0x7fa <lcd1602_init+0x5a>
     7fa:	00 00       	nop
	_delay_ms(1);
	lcd1602_send_byte(0x28, LCD_COMMAND);
     7fc:	60 e0       	ldi	r22, 0x00	; 0
     7fe:	88 e2       	ldi	r24, 0x28	; 40
     800:	0e 94 9a 03 	call	0x734	; 0x734 <lcd1602_send_byte>
     804:	8f e9       	ldi	r24, 0x9F	; 159
     806:	9f e0       	ldi	r25, 0x0F	; 15
     808:	01 97       	sbiw	r24, 0x01	; 1
     80a:	f1 f7       	brne	.-4      	; 0x808 <lcd1602_init+0x68>
     80c:	00 c0       	rjmp	.+0      	; 0x80e <lcd1602_init+0x6e>
     80e:	00 00       	nop
	_delay_ms(1);
	lcd1602_send_byte(0x0C, LCD_COMMAND);
     810:	60 e0       	ldi	r22, 0x00	; 0
     812:	8c e0       	ldi	r24, 0x0C	; 12
     814:	0e 94 9a 03 	call	0x734	; 0x734 <lcd1602_send_byte>
     818:	8f e9       	ldi	r24, 0x9F	; 159
     81a:	9f e0       	ldi	r25, 0x0F	; 15
     81c:	01 97       	sbiw	r24, 0x01	; 1
     81e:	f1 f7       	brne	.-4      	; 0x81c <lcd1602_init+0x7c>
     820:	00 c0       	rjmp	.+0      	; 0x822 <lcd1602_init+0x82>
     822:	00 00       	nop
	_delay_ms(1);
	lcd1602_send_byte(0x06, LCD_COMMAND);
     824:	60 e0       	ldi	r22, 0x00	; 0
     826:	86 e0       	ldi	r24, 0x06	; 6
     828:	0e 94 9a 03 	call	0x734	; 0x734 <lcd1602_send_byte>
     82c:	8f e9       	ldi	r24, 0x9F	; 159
     82e:	9f e0       	ldi	r25, 0x0F	; 15
     830:	01 97       	sbiw	r24, 0x01	; 1
     832:	f1 f7       	brne	.-4      	; 0x830 <lcd1602_init+0x90>
     834:	00 c0       	rjmp	.+0      	; 0x836 <lcd1602_init+0x96>
     836:	00 00       	nop
	_delay_ms(1);
	i2c_send_packet(lcd.led_pin |= 0x08, SLA_W);
     838:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     83c:	88 60       	ori	r24, 0x08	; 8
     83e:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     842:	6e e4       	ldi	r22, 0x4E	; 78
     844:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
	i2c_send_packet(lcd.led_pin &=~ 0x02, SLA_W);
     848:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <lcd>
     84c:	8d 7f       	andi	r24, 0xFD	; 253
     84e:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <lcd>
     852:	6e e4       	ldi	r22, 0x4E	; 78
     854:	0e 94 60 03 	call	0x6c0	; 0x6c0 <i2c_send_packet>
     858:	08 95       	ret

0000085a <lcd1602_clear>:
}

void lcd1602_clear()
{
	lcd1602_send_byte(0x01, LCD_COMMAND);
     85a:	60 e0       	ldi	r22, 0x00	; 0
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 9a 03 	call	0x734	; 0x734 <lcd1602_send_byte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     862:	8f e6       	ldi	r24, 0x6F	; 111
     864:	97 e1       	ldi	r25, 0x17	; 23
     866:	01 97       	sbiw	r24, 0x01	; 1
     868:	f1 f7       	brne	.-4      	; 0x866 <lcd1602_clear+0xc>
     86a:	00 c0       	rjmp	.+0      	; 0x86c <lcd1602_clear+0x12>
     86c:	00 00       	nop
     86e:	08 95       	ret

00000870 <lcd1602_goto_xy>:

void lcd1602_goto_xy(char col, char row)
{
	char adr;

	adr = 0x40*row + col;
     870:	90 e4       	ldi	r25, 0x40	; 64
     872:	69 9f       	mul	r22, r25
     874:	80 0d       	add	r24, r0
     876:	11 24       	eor	r1, r1
	adr |= 0x80;
	lcd1602_send_byte(adr, LCD_COMMAND);
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	80 68       	ori	r24, 0x80	; 128
     87c:	0e 94 9a 03 	call	0x734	; 0x734 <lcd1602_send_byte>
     880:	08 95       	ret

00000882 <lcd1602_send_string>:
}

void lcd1602_send_string(const char *str)
{
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	fc 01       	movw	r30, r24
	uint8_t i;

	for(i = 0; str[i] != '\0'; i++)
     88a:	80 81       	ld	r24, Z
     88c:	88 23       	and	r24, r24
     88e:	59 f0       	breq	.+22     	; 0x8a6 <lcd1602_send_string+0x24>
     890:	8f 01       	movw	r16, r30
     892:	c0 e0       	ldi	r28, 0x00	; 0
		lcd1602_send_char(str[i]);
     894:	0e 94 bc 03 	call	0x778	; 0x778 <lcd1602_send_char>

void lcd1602_send_string(const char *str)
{
	uint8_t i;

	for(i = 0; str[i] != '\0'; i++)
     898:	cf 5f       	subi	r28, 0xFF	; 255
     89a:	f8 01       	movw	r30, r16
     89c:	ec 0f       	add	r30, r28
     89e:	f1 1d       	adc	r31, r1
     8a0:	80 81       	ld	r24, Z
     8a2:	81 11       	cpse	r24, r1
     8a4:	f7 cf       	rjmp	.-18     	; 0x894 <lcd1602_send_string+0x12>
		lcd1602_send_char(str[i]);
}
     8a6:	cf 91       	pop	r28
     8a8:	1f 91       	pop	r17
     8aa:	0f 91       	pop	r16
     8ac:	08 95       	ret

000008ae <pwm_init>:
#include "common.h"

void pwm_init()
{
	
	DDRB |= 1<<DDB0; //dig 8
     8ae:	20 9a       	sbi	0x04, 0	; 4
	DDRB |= (1 << DDB1)|(1 << DDB2); //izlazni pinovi za PWM - D9 i D10 na Arduino Uno ploci
     8b0:	84 b1       	in	r24, 0x04	; 4
     8b2:	86 60       	ori	r24, 0x06	; 6
     8b4:	84 b9       	out	0x04, r24	; 4
	

	ICR1 = 400;			//frekvencija ~ 40 kHz
     8b6:	80 e9       	ldi	r24, 0x90	; 144
     8b8:	91 e0       	ldi	r25, 0x01	; 1
     8ba:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     8be:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	OCR1A = 0;		    //faktor ispune 0% 
     8c2:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     8c6:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	//OCR1B = OCR1A;
	
	TCCR1A = 0b10000010;		//jedan izlaz, fast pwm
     8ca:	82 e8       	ldi	r24, 0x82	; 130
     8cc:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B |= (1 << WGM13)|(1 << WGM12);		// set Fast PWM mode using ICR1 as TOP
     8d0:	e1 e8       	ldi	r30, 0x81	; 129
     8d2:	f0 e0       	ldi	r31, 0x00	; 0
     8d4:	80 81       	ld	r24, Z
     8d6:	88 61       	ori	r24, 0x18	; 24
     8d8:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS10);		// START the timer with no prescaler	
     8da:	80 81       	ld	r24, Z
     8dc:	81 60       	ori	r24, 0x01	; 1
     8de:	80 83       	st	Z, r24
     8e0:	08 95       	ret

000008e2 <__vector_11>:
	
	//upis i promena faktora ispune se vrsi u ad konverziji
}

ISR(TIMER1_COMPA_vect)
{
     8e2:	1f 92       	push	r1
     8e4:	0f 92       	push	r0
     8e6:	0f b6       	in	r0, 0x3f	; 63
     8e8:	0f 92       	push	r0
     8ea:	11 24       	eor	r1, r1
	//ADCSRA |= 1<<ADSC; //start ad conversion
	
	PINB |= 0b1;
     8ec:	18 9a       	sbi	0x03, 0	; 3
     8ee:	0f 90       	pop	r0
     8f0:	0f be       	out	0x3f, r0	; 63
     8f2:	0f 90       	pop	r0
     8f4:	1f 90       	pop	r1
     8f6:	18 95       	reti

000008f8 <tajmer0_init>:
//const volatile double stepeniPOms_to_rpm = 16.67;		//faktor konverzije izmedju izmerenog broja stepeni u prozoru od 10ms u obrtaje po minutu
//volatile double relativni_ugao = 0;

void tajmer0_init()
{
	TCCR0A = 0b10;		//CTC mode, TOP=OCR0A
     8f8:	82 e0       	ldi	r24, 0x02	; 2
     8fa:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0b11;		//prescaler = 64
     8fc:	93 e0       	ldi	r25, 0x03	; 3
     8fe:	95 bd       	out	0x25, r25	; 37
	OCR0A = 249;		//da bi se dobila frekvencija 1kHz odnosno prekid na svaki 1ms
     900:	99 ef       	ldi	r25, 0xF9	; 249
     902:	97 bd       	out	0x27, r25	; 39
	TIMSK0 = 0b10;		//compare match A interrupt enable
     904:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	
	DDRB |= 1<<PINB5;
     908:	25 9a       	sbi	0x04, 5	; 4
     90a:	08 95       	ret

0000090c <__vector_14>:
}

ISR(TIMER0_COMPA_vect)   //1ms prekid
{
     90c:	1f 92       	push	r1
     90e:	0f 92       	push	r0
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	0f 92       	push	r0
     914:	11 24       	eor	r1, r1
     916:	cf 92       	push	r12
     918:	df 92       	push	r13
     91a:	ef 92       	push	r14
     91c:	ff 92       	push	r15
     91e:	0f 93       	push	r16
     920:	1f 93       	push	r17
     922:	2f 93       	push	r18
     924:	3f 93       	push	r19
     926:	4f 93       	push	r20
     928:	5f 93       	push	r21
     92a:	6f 93       	push	r22
     92c:	7f 93       	push	r23
     92e:	8f 93       	push	r24
     930:	9f 93       	push	r25
     932:	af 93       	push	r26
     934:	bf 93       	push	r27
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	ef 93       	push	r30
     93c:	ff 93       	push	r31
	flag_tajmer0_prekid = 1;
     93e:	81 e0       	ldi	r24, 0x01	; 1
     940:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <flag_tajmer0_prekid>
	
	brojac_prekida_tajmera0++;	//prekid okida svaki 1ms
     944:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <brojac_prekida_tajmera0>
     948:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <brojac_prekida_tajmera0+0x1>
     94c:	01 96       	adiw	r24, 0x01	; 1
     94e:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <brojac_prekida_tajmera0+0x1>
     952:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <brojac_prekida_tajmera0>
	
		
	if(brojac_prekida_tajmera0 == 10)
     956:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <brojac_prekida_tajmera0>
     95a:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <brojac_prekida_tajmera0+0x1>
     95e:	0a 97       	sbiw	r24, 0x0a	; 10
     960:	41 f4       	brne	.+16     	; 0x972 <__vector_14+0x66>
	{
		brojac_prekida_tajmera0 = 0;
     962:	10 92 df 01 	sts	0x01DF, r1	; 0x8001df <brojac_prekida_tajmera0+0x1>
     966:	10 92 de 01 	sts	0x01DE, r1	; 0x8001de <brojac_prekida_tajmera0>
		flag_prekid_10ms = 1;
     96a:	81 e0       	ldi	r24, 0x01	; 1
     96c:	80 93 db 01 	sts	0x01DB, r24	; 0x8001db <flag_prekid_10ms>
		PINB |= 1<<PINB5;					//toogle pin 5 - DIG13, test da vidim da li je korektna frekvencija
     970:	1d 9a       	sbi	0x03, 5	; 3
	
	/*Podsetnik: postoje inkrementalni i neki drugi PID zakon, pa ih malo prouci*/
	


			greska_prethodna = greska; //zapamtim proslu gresku pre racunanja nove
     972:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <greska>
     976:	90 91 d6 01 	lds	r25, 0x01D6	; 0x8001d6 <greska+0x1>
     97a:	a0 91 d7 01 	lds	r26, 0x01D7	; 0x8001d7 <greska+0x2>
     97e:	b0 91 d8 01 	lds	r27, 0x01D8	; 0x8001d8 <greska+0x3>
     982:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <greska_prethodna>
     986:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <greska_prethodna+0x1>
     98a:	a0 93 cf 01 	sts	0x01CF, r26	; 0x8001cf <greska_prethodna+0x2>
     98e:	b0 93 d0 01 	sts	0x01D0, r27	; 0x8001d0 <greska_prethodna+0x3>

			greska = (int32_t)ref_napon_sa_pot - mereni_napon;    //greska napona (u mV)
     992:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <ref_napon_sa_pot>
     996:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <ref_napon_sa_pot+0x1>
     99a:	40 91 20 01 	lds	r20, 0x0120	; 0x800120 <mereni_napon>
     99e:	50 91 21 01 	lds	r21, 0x0121	; 0x800121 <mereni_napon+0x1>
     9a2:	a0 e0       	ldi	r26, 0x00	; 0
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
     9a6:	05 2e       	mov	r0, r21
     9a8:	00 0c       	add	r0, r0
     9aa:	66 0b       	sbc	r22, r22
     9ac:	77 0b       	sbc	r23, r23
     9ae:	84 1b       	sub	r24, r20
     9b0:	95 0b       	sbc	r25, r21
     9b2:	a6 0b       	sbc	r26, r22
     9b4:	b7 0b       	sbc	r27, r23
     9b6:	80 93 d5 01 	sts	0x01D5, r24	; 0x8001d5 <greska>
     9ba:	90 93 d6 01 	sts	0x01D6, r25	; 0x8001d6 <greska+0x1>
     9be:	a0 93 d7 01 	sts	0x01D7, r26	; 0x8001d7 <greska+0x2>
     9c2:	b0 93 d8 01 	sts	0x01D8, r27	; 0x8001d8 <greska+0x3>
																 //desavao se overflow zato sto je ref_napon unsigned, posle kastovanja sve u redu
				
			Upravljanje = Kp*greska;	  //Proporcionalno dejstvo,      400 = max (~20V), 0 = min (0V)
     9c6:	60 91 d5 01 	lds	r22, 0x01D5	; 0x8001d5 <greska>
     9ca:	70 91 d6 01 	lds	r23, 0x01D6	; 0x8001d6 <greska+0x1>
     9ce:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <greska+0x2>
     9d2:	90 91 d8 01 	lds	r25, 0x01D8	; 0x8001d8 <greska+0x3>
     9d6:	c0 90 0c 01 	lds	r12, 0x010C	; 0x80010c <Kp>
     9da:	d0 90 0d 01 	lds	r13, 0x010D	; 0x80010d <Kp+0x1>
     9de:	e0 90 0e 01 	lds	r14, 0x010E	; 0x80010e <Kp+0x2>
     9e2:	f0 90 0f 01 	lds	r15, 0x010F	; 0x80010f <Kp+0x3>
     9e6:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     9ea:	a7 01       	movw	r20, r14
     9ec:	96 01       	movw	r18, r12
     9ee:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     9f2:	0e 94 fd 06 	call	0xdfa	; 0xdfa <__fixsfsi>
     9f6:	70 93 da 01 	sts	0x01DA, r23	; 0x8001da <Upravljanje+0x1>
     9fa:	60 93 d9 01 	sts	0x01D9, r22	; 0x8001d9 <Upravljanje>
			
			
			suma_greske += greska;
     9fe:	40 91 d5 01 	lds	r20, 0x01D5	; 0x8001d5 <greska>
     a02:	50 91 d6 01 	lds	r21, 0x01D6	; 0x8001d6 <greska+0x1>
     a06:	60 91 d7 01 	lds	r22, 0x01D7	; 0x8001d7 <greska+0x2>
     a0a:	70 91 d8 01 	lds	r23, 0x01D8	; 0x8001d8 <greska+0x3>
     a0e:	80 91 d1 01 	lds	r24, 0x01D1	; 0x8001d1 <suma_greske>
     a12:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     a16:	a0 91 d3 01 	lds	r26, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     a1a:	b0 91 d4 01 	lds	r27, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     a1e:	84 0f       	add	r24, r20
     a20:	95 1f       	adc	r25, r21
     a22:	a6 1f       	adc	r26, r22
     a24:	b7 1f       	adc	r27, r23
     a26:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <suma_greske>
     a2a:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <suma_greske+0x1>
     a2e:	a0 93 d3 01 	sts	0x01D3, r26	; 0x8001d3 <suma_greske+0x2>
     a32:	b0 93 d4 01 	sts	0x01D4, r27	; 0x8001d4 <suma_greske+0x3>
			
			if(suma_greske >= limit_sume)
     a36:	40 91 d1 01 	lds	r20, 0x01D1	; 0x8001d1 <suma_greske>
     a3a:	50 91 d2 01 	lds	r21, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     a3e:	60 91 d3 01 	lds	r22, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     a42:	70 91 d4 01 	lds	r23, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     a46:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     a4a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     a4e:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <__data_start+0x2>
     a52:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <__data_start+0x3>
     a56:	48 17       	cp	r20, r24
     a58:	59 07       	cpc	r21, r25
     a5a:	6a 07       	cpc	r22, r26
     a5c:	7b 07       	cpc	r23, r27
     a5e:	8c f0       	brlt	.+34     	; 0xa82 <__vector_14+0x176>
				suma_greske = limit_sume;
     a60:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     a64:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     a68:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <__data_start+0x2>
     a6c:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <__data_start+0x3>
     a70:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <suma_greske>
     a74:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <suma_greske+0x1>
     a78:	a0 93 d3 01 	sts	0x01D3, r26	; 0x8001d3 <suma_greske+0x2>
     a7c:	b0 93 d4 01 	sts	0x01D4, r27	; 0x8001d4 <suma_greske+0x3>
     a80:	15 c0       	rjmp	.+42     	; 0xaac <__vector_14+0x1a0>
			else if (suma_greske <= 0)
     a82:	80 91 d1 01 	lds	r24, 0x01D1	; 0x8001d1 <suma_greske>
     a86:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     a8a:	a0 91 d3 01 	lds	r26, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     a8e:	b0 91 d4 01 	lds	r27, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     a92:	18 16       	cp	r1, r24
     a94:	19 06       	cpc	r1, r25
     a96:	1a 06       	cpc	r1, r26
     a98:	1b 06       	cpc	r1, r27
     a9a:	44 f0       	brlt	.+16     	; 0xaac <__vector_14+0x1a0>
				suma_greske = 0;
     a9c:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <suma_greske>
     aa0:	10 92 d2 01 	sts	0x01D2, r1	; 0x8001d2 <suma_greske+0x1>
     aa4:	10 92 d3 01 	sts	0x01D3, r1	; 0x8001d3 <suma_greske+0x2>
     aa8:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <suma_greske+0x3>
			
			
			Upravljanje += Ki * suma_greske;		//Integralno dejstvo sabiram sa P dejstvom
     aac:	60 91 d1 01 	lds	r22, 0x01D1	; 0x8001d1 <suma_greske>
     ab0:	70 91 d2 01 	lds	r23, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     ab4:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     ab8:	90 91 d4 01 	lds	r25, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     abc:	c0 90 08 01 	lds	r12, 0x0108	; 0x800108 <Ki>
     ac0:	d0 90 09 01 	lds	r13, 0x0109	; 0x800109 <Ki+0x1>
     ac4:	e0 90 0a 01 	lds	r14, 0x010A	; 0x80010a <Ki+0x2>
     ac8:	f0 90 0b 01 	lds	r15, 0x010B	; 0x80010b <Ki+0x3>
     acc:	c0 91 d9 01 	lds	r28, 0x01D9	; 0x8001d9 <Upravljanje>
     ad0:	d0 91 da 01 	lds	r29, 0x01DA	; 0x8001da <Upravljanje+0x1>
     ad4:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     ad8:	a7 01       	movw	r20, r14
     ada:	96 01       	movw	r18, r12
     adc:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     ae0:	6b 01       	movw	r12, r22
     ae2:	7c 01       	movw	r14, r24
     ae4:	be 01       	movw	r22, r28
     ae6:	dd 0f       	add	r29, r29
     ae8:	88 0b       	sbc	r24, r24
     aea:	99 0b       	sbc	r25, r25
     aec:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     af0:	9b 01       	movw	r18, r22
     af2:	ac 01       	movw	r20, r24
     af4:	c7 01       	movw	r24, r14
     af6:	b6 01       	movw	r22, r12
     af8:	0e 94 91 06 	call	0xd22	; 0xd22 <__addsf3>
     afc:	0e 94 fd 06 	call	0xdfa	; 0xdfa <__fixsfsi>
     b00:	70 93 da 01 	sts	0x01DA, r23	; 0x8001da <Upravljanje+0x1>
     b04:	60 93 d9 01 	sts	0x01D9, r22	; 0x8001d9 <Upravljanje>
			
			
			Upravljanje += Kd * (greska - greska_prethodna);	//Diferencijalno dejstvo. Znacajno poboljsalo ponasanje.
     b08:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <greska>
     b0c:	90 91 d6 01 	lds	r25, 0x01D6	; 0x8001d6 <greska+0x1>
     b10:	a0 91 d7 01 	lds	r26, 0x01D7	; 0x8001d7 <greska+0x2>
     b14:	b0 91 d8 01 	lds	r27, 0x01D8	; 0x8001d8 <greska+0x3>
     b18:	00 91 cd 01 	lds	r16, 0x01CD	; 0x8001cd <greska_prethodna>
     b1c:	10 91 ce 01 	lds	r17, 0x01CE	; 0x8001ce <greska_prethodna+0x1>
     b20:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <greska_prethodna+0x2>
     b24:	30 91 d0 01 	lds	r19, 0x01D0	; 0x8001d0 <greska_prethodna+0x3>
     b28:	c0 90 04 01 	lds	r12, 0x0104	; 0x800104 <Kd>
     b2c:	d0 90 05 01 	lds	r13, 0x0105	; 0x800105 <Kd+0x1>
     b30:	e0 90 06 01 	lds	r14, 0x0106	; 0x800106 <Kd+0x2>
     b34:	f0 90 07 01 	lds	r15, 0x0107	; 0x800107 <Kd+0x3>
     b38:	c0 91 d9 01 	lds	r28, 0x01D9	; 0x8001d9 <Upravljanje>
     b3c:	d0 91 da 01 	lds	r29, 0x01DA	; 0x8001da <Upravljanje+0x1>
     b40:	bc 01       	movw	r22, r24
     b42:	cd 01       	movw	r24, r26
     b44:	60 1b       	sub	r22, r16
     b46:	71 0b       	sbc	r23, r17
     b48:	82 0b       	sbc	r24, r18
     b4a:	93 0b       	sbc	r25, r19
     b4c:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     b50:	a7 01       	movw	r20, r14
     b52:	96 01       	movw	r18, r12
     b54:	0e 94 c1 07 	call	0xf82	; 0xf82 <__mulsf3>
     b58:	6b 01       	movw	r12, r22
     b5a:	7c 01       	movw	r14, r24
     b5c:	be 01       	movw	r22, r28
     b5e:	dd 0f       	add	r29, r29
     b60:	88 0b       	sbc	r24, r24
     b62:	99 0b       	sbc	r25, r25
     b64:	0e 94 35 07 	call	0xe6a	; 0xe6a <__floatsisf>
     b68:	9b 01       	movw	r18, r22
     b6a:	ac 01       	movw	r20, r24
     b6c:	c7 01       	movw	r24, r14
     b6e:	b6 01       	movw	r22, r12
     b70:	0e 94 91 06 	call	0xd22	; 0xd22 <__addsf3>
     b74:	0e 94 fd 06 	call	0xdfa	; 0xdfa <__fixsfsi>
     b78:	70 93 da 01 	sts	0x01DA, r23	; 0x8001da <Upravljanje+0x1>
     b7c:	60 93 d9 01 	sts	0x01D9, r22	; 0x8001d9 <Upravljanje>
			
			
			if(Upravljanje>=400)
     b80:	80 91 d9 01 	lds	r24, 0x01D9	; 0x8001d9 <Upravljanje>
     b84:	90 91 da 01 	lds	r25, 0x01DA	; 0x8001da <Upravljanje+0x1>
     b88:	80 39       	cpi	r24, 0x90	; 144
     b8a:	91 40       	sbci	r25, 0x01	; 1
     b8c:	1c f1       	brlt	.+70     	; 0xbd4 <__vector_14+0x2c8>
			{
				Upravljanje = 400; //saturacija, tj ogranicenje
     b8e:	80 e9       	ldi	r24, 0x90	; 144
     b90:	91 e0       	ldi	r25, 0x01	; 1
     b92:	90 93 da 01 	sts	0x01DA, r25	; 0x8001da <Upravljanje+0x1>
     b96:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <Upravljanje>
				suma_greske -= greska;		//ako vec imas max upravljanje nemoj vise povecavati sumu greske; zastita od wind up-a
     b9a:	40 91 d5 01 	lds	r20, 0x01D5	; 0x8001d5 <greska>
     b9e:	50 91 d6 01 	lds	r21, 0x01D6	; 0x8001d6 <greska+0x1>
     ba2:	60 91 d7 01 	lds	r22, 0x01D7	; 0x8001d7 <greska+0x2>
     ba6:	70 91 d8 01 	lds	r23, 0x01D8	; 0x8001d8 <greska+0x3>
     baa:	80 91 d1 01 	lds	r24, 0x01D1	; 0x8001d1 <suma_greske>
     bae:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     bb2:	a0 91 d3 01 	lds	r26, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     bb6:	b0 91 d4 01 	lds	r27, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     bba:	84 1b       	sub	r24, r20
     bbc:	95 0b       	sbc	r25, r21
     bbe:	a6 0b       	sbc	r26, r22
     bc0:	b7 0b       	sbc	r27, r23
     bc2:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <suma_greske>
     bc6:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <suma_greske+0x1>
     bca:	a0 93 d3 01 	sts	0x01D3, r26	; 0x8001d3 <suma_greske+0x2>
     bce:	b0 93 d4 01 	sts	0x01D4, r27	; 0x8001d4 <suma_greske+0x3>
     bd2:	27 c0       	rjmp	.+78     	; 0xc22 <__vector_14+0x316>
			}
			
			else if(Upravljanje<=0)
     bd4:	80 91 d9 01 	lds	r24, 0x01D9	; 0x8001d9 <Upravljanje>
     bd8:	90 91 da 01 	lds	r25, 0x01DA	; 0x8001da <Upravljanje+0x1>
     bdc:	18 16       	cp	r1, r24
     bde:	19 06       	cpc	r1, r25
     be0:	04 f1       	brlt	.+64     	; 0xc22 <__vector_14+0x316>
			{
				Upravljanje = 0;
     be2:	10 92 da 01 	sts	0x01DA, r1	; 0x8001da <Upravljanje+0x1>
     be6:	10 92 d9 01 	sts	0x01D9, r1	; 0x8001d9 <Upravljanje>
				suma_greske -= greska;		//ako vec imas min upravljanje nemoj vise povecavati sumu greske; zastita od wind up-a
     bea:	40 91 d5 01 	lds	r20, 0x01D5	; 0x8001d5 <greska>
     bee:	50 91 d6 01 	lds	r21, 0x01D6	; 0x8001d6 <greska+0x1>
     bf2:	60 91 d7 01 	lds	r22, 0x01D7	; 0x8001d7 <greska+0x2>
     bf6:	70 91 d8 01 	lds	r23, 0x01D8	; 0x8001d8 <greska+0x3>
     bfa:	80 91 d1 01 	lds	r24, 0x01D1	; 0x8001d1 <suma_greske>
     bfe:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <suma_greske+0x1>
     c02:	a0 91 d3 01 	lds	r26, 0x01D3	; 0x8001d3 <suma_greske+0x2>
     c06:	b0 91 d4 01 	lds	r27, 0x01D4	; 0x8001d4 <suma_greske+0x3>
     c0a:	84 1b       	sub	r24, r20
     c0c:	95 0b       	sbc	r25, r21
     c0e:	a6 0b       	sbc	r26, r22
     c10:	b7 0b       	sbc	r27, r23
     c12:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <suma_greske>
     c16:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <suma_greske+0x1>
     c1a:	a0 93 d3 01 	sts	0x01D3, r26	; 0x8001d3 <suma_greske+0x2>
     c1e:	b0 93 d4 01 	sts	0x01D4, r27	; 0x8001d4 <suma_greske+0x3>
			}
			
			
			OCR1A = (uint16_t)Upravljanje;	//i na kraju upis faktora ispune. Promenljiva "Upravljanje" je svojevrstan bafer.
     c22:	80 91 d9 01 	lds	r24, 0x01D9	; 0x8001d9 <Upravljanje>
     c26:	90 91 da 01 	lds	r25, 0x01DA	; 0x8001da <Upravljanje+0x1>
     c2a:	e8 e8       	ldi	r30, 0x88	; 136
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	91 83       	std	Z+1, r25	; 0x01
     c30:	80 83       	st	Z, r24
			
			OCR1A = 100; //debagovanje
     c32:	84 e6       	ldi	r24, 0x64	; 100
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	91 83       	std	Z+1, r25	; 0x01
     c38:	80 83       	st	Z, r24
	
     c3a:	ff 91       	pop	r31
     c3c:	ef 91       	pop	r30
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	bf 91       	pop	r27
     c44:	af 91       	pop	r26
     c46:	9f 91       	pop	r25
     c48:	8f 91       	pop	r24
     c4a:	7f 91       	pop	r23
     c4c:	6f 91       	pop	r22
     c4e:	5f 91       	pop	r21
     c50:	4f 91       	pop	r20
     c52:	3f 91       	pop	r19
     c54:	2f 91       	pop	r18
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
     c5c:	ef 90       	pop	r14
     c5e:	df 90       	pop	r13
     c60:	cf 90       	pop	r12
     c62:	0f 90       	pop	r0
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	0f 90       	pop	r0
     c68:	1f 90       	pop	r1
     c6a:	18 95       	reti

00000c6c <__vector_20>:
volatile unsigned char poslato;
volatile unsigned char input_char;
volatile unsigned char input_buffer[INPUT_BUFF_SIZE], buff_size=0;

ISR(USART_TX_vect)
{
     c6c:	1f 92       	push	r1
     c6e:	0f 92       	push	r0
     c70:	0f b6       	in	r0, 0x3f	; 63
     c72:	0f 92       	push	r0
     c74:	11 24       	eor	r1, r1
	poslato=0;
     c76:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <poslato>
}
     c7a:	0f 90       	pop	r0
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	0f 90       	pop	r0
     c80:	1f 90       	pop	r1
     c82:	18 95       	reti

00000c84 <__vector_18>:

ISR(USART_RX_vect)
{
     c84:	1f 92       	push	r1
     c86:	0f 92       	push	r0
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	0f 92       	push	r0
     c8c:	11 24       	eor	r1, r1
     c8e:	8f 93       	push	r24
     c90:	ef 93       	push	r30
     c92:	ff 93       	push	r31
	input_char=UDR0;
     c94:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     c98:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <input_char>
	
	if (buff_size<INPUT_BUFF_SIZE)
     c9c:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <buff_size>
     ca0:	88 30       	cpi	r24, 0x08	; 8
     ca2:	98 f4       	brcc	.+38     	; 0xcca <__vector_18+0x46>
	{
		input_buffer[buff_size]=input_char;
     ca4:	e0 91 dd 01 	lds	r30, 0x01DD	; 0x8001dd <buff_size>
     ca8:	f0 e0       	ldi	r31, 0x00	; 0
     caa:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <input_char>
     cae:	ee 51       	subi	r30, 0x1E	; 30
     cb0:	fe 4f       	sbci	r31, 0xFE	; 254
     cb2:	80 83       	st	Z, r24
		buff_size++;
     cb4:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <buff_size>
     cb8:	8f 5f       	subi	r24, 0xFF	; 255
     cba:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <buff_size>
		input_buffer[buff_size]='\0';
     cbe:	e0 91 dd 01 	lds	r30, 0x01DD	; 0x8001dd <buff_size>
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	ee 51       	subi	r30, 0x1E	; 30
     cc6:	fe 4f       	sbci	r31, 0xFE	; 254
     cc8:	10 82       	st	Z, r1
	}
}
     cca:	ff 91       	pop	r31
     ccc:	ef 91       	pop	r30
     cce:	8f 91       	pop	r24
     cd0:	0f 90       	pop	r0
     cd2:	0f be       	out	0x3f, r0	; 63
     cd4:	0f 90       	pop	r0
     cd6:	1f 90       	pop	r1
     cd8:	18 95       	reti

00000cda <uart_init>:

void uart_init()
{
	UCSR0A = 0b10;		//dupla brzina slanja
     cda:	82 e0       	ldi	r24, 0x02	; 2
     cdc:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	UCSR0B = 0b11011000;	//RX complete interupt enable; TX complete interupt enable; Receiver enable; Transmitter enable
     ce0:	88 ed       	ldi	r24, 0xD8	; 216
     ce2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	UCSR0C = 0b110;			//asinhroni rezim, 8-bit, no parity, 1 stop bit
     ce6:	86 e0       	ldi	r24, 0x06	; 6
     ce8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	UBRR0 = 207;	//Baud 9600 bps
     cec:	8f ec       	ldi	r24, 0xCF	; 207
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     cf4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     cf8:	08 95       	ret

00000cfa <send_str>:
}

void send_str(unsigned char *str)
{
     cfa:	fc 01       	movw	r30, r24
	//funkcija za slanje stringova
	
	
	while (*str!='\0')
     cfc:	90 81       	ld	r25, Z
     cfe:	99 23       	and	r25, r25
     d00:	71 f0       	breq	.+28     	; 0xd1e <send_str+0x24>
     d02:	31 96       	adiw	r30, 0x01	; 1
	{
		UDR0=*str;
     d04:	a6 ec       	ldi	r26, 0xC6	; 198
     d06:	b0 e0       	ldi	r27, 0x00	; 0
		poslato=1;
     d08:	81 e0       	ldi	r24, 0x01	; 1
	//funkcija za slanje stringova
	
	
	while (*str!='\0')
	{
		UDR0=*str;
     d0a:	9c 93       	st	X, r25
		poslato=1;
     d0c:	80 93 e1 01 	sts	0x01E1, r24	; 0x8001e1 <poslato>
		while (poslato);
     d10:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <poslato>
     d14:	91 11       	cpse	r25, r1
     d16:	fc cf       	rjmp	.-8      	; 0xd10 <send_str+0x16>
void send_str(unsigned char *str)
{
	//funkcija za slanje stringova
	
	
	while (*str!='\0')
     d18:	91 91       	ld	r25, Z+
     d1a:	91 11       	cpse	r25, r1
     d1c:	f6 cf       	rjmp	.-20     	; 0xd0a <send_str+0x10>
     d1e:	08 95       	ret

00000d20 <__subsf3>:
     d20:	50 58       	subi	r21, 0x80	; 128

00000d22 <__addsf3>:
     d22:	bb 27       	eor	r27, r27
     d24:	aa 27       	eor	r26, r26
     d26:	0e 94 a8 06 	call	0xd50	; 0xd50 <__addsf3x>
     d2a:	0c 94 87 07 	jmp	0xf0e	; 0xf0e <__fp_round>
     d2e:	0e 94 79 07 	call	0xef2	; 0xef2 <__fp_pscA>
     d32:	38 f0       	brcs	.+14     	; 0xd42 <__addsf3+0x20>
     d34:	0e 94 80 07 	call	0xf00	; 0xf00 <__fp_pscB>
     d38:	20 f0       	brcs	.+8      	; 0xd42 <__addsf3+0x20>
     d3a:	39 f4       	brne	.+14     	; 0xd4a <__addsf3+0x28>
     d3c:	9f 3f       	cpi	r25, 0xFF	; 255
     d3e:	19 f4       	brne	.+6      	; 0xd46 <__addsf3+0x24>
     d40:	26 f4       	brtc	.+8      	; 0xd4a <__addsf3+0x28>
     d42:	0c 94 76 07 	jmp	0xeec	; 0xeec <__fp_nan>
     d46:	0e f4       	brtc	.+2      	; 0xd4a <__addsf3+0x28>
     d48:	e0 95       	com	r30
     d4a:	e7 fb       	bst	r30, 7
     d4c:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__fp_inf>

00000d50 <__addsf3x>:
     d50:	e9 2f       	mov	r30, r25
     d52:	0e 94 98 07 	call	0xf30	; 0xf30 <__fp_split3>
     d56:	58 f3       	brcs	.-42     	; 0xd2e <__addsf3+0xc>
     d58:	ba 17       	cp	r27, r26
     d5a:	62 07       	cpc	r22, r18
     d5c:	73 07       	cpc	r23, r19
     d5e:	84 07       	cpc	r24, r20
     d60:	95 07       	cpc	r25, r21
     d62:	20 f0       	brcs	.+8      	; 0xd6c <__addsf3x+0x1c>
     d64:	79 f4       	brne	.+30     	; 0xd84 <__addsf3x+0x34>
     d66:	a6 f5       	brtc	.+104    	; 0xdd0 <__addsf3x+0x80>
     d68:	0c 94 ba 07 	jmp	0xf74	; 0xf74 <__fp_zero>
     d6c:	0e f4       	brtc	.+2      	; 0xd70 <__addsf3x+0x20>
     d6e:	e0 95       	com	r30
     d70:	0b 2e       	mov	r0, r27
     d72:	ba 2f       	mov	r27, r26
     d74:	a0 2d       	mov	r26, r0
     d76:	0b 01       	movw	r0, r22
     d78:	b9 01       	movw	r22, r18
     d7a:	90 01       	movw	r18, r0
     d7c:	0c 01       	movw	r0, r24
     d7e:	ca 01       	movw	r24, r20
     d80:	a0 01       	movw	r20, r0
     d82:	11 24       	eor	r1, r1
     d84:	ff 27       	eor	r31, r31
     d86:	59 1b       	sub	r21, r25
     d88:	99 f0       	breq	.+38     	; 0xdb0 <__addsf3x+0x60>
     d8a:	59 3f       	cpi	r21, 0xF9	; 249
     d8c:	50 f4       	brcc	.+20     	; 0xda2 <__addsf3x+0x52>
     d8e:	50 3e       	cpi	r21, 0xE0	; 224
     d90:	68 f1       	brcs	.+90     	; 0xdec <__addsf3x+0x9c>
     d92:	1a 16       	cp	r1, r26
     d94:	f0 40       	sbci	r31, 0x00	; 0
     d96:	a2 2f       	mov	r26, r18
     d98:	23 2f       	mov	r18, r19
     d9a:	34 2f       	mov	r19, r20
     d9c:	44 27       	eor	r20, r20
     d9e:	58 5f       	subi	r21, 0xF8	; 248
     da0:	f3 cf       	rjmp	.-26     	; 0xd88 <__addsf3x+0x38>
     da2:	46 95       	lsr	r20
     da4:	37 95       	ror	r19
     da6:	27 95       	ror	r18
     da8:	a7 95       	ror	r26
     daa:	f0 40       	sbci	r31, 0x00	; 0
     dac:	53 95       	inc	r21
     dae:	c9 f7       	brne	.-14     	; 0xda2 <__addsf3x+0x52>
     db0:	7e f4       	brtc	.+30     	; 0xdd0 <__addsf3x+0x80>
     db2:	1f 16       	cp	r1, r31
     db4:	ba 0b       	sbc	r27, r26
     db6:	62 0b       	sbc	r22, r18
     db8:	73 0b       	sbc	r23, r19
     dba:	84 0b       	sbc	r24, r20
     dbc:	ba f0       	brmi	.+46     	; 0xdec <__addsf3x+0x9c>
     dbe:	91 50       	subi	r25, 0x01	; 1
     dc0:	a1 f0       	breq	.+40     	; 0xdea <__addsf3x+0x9a>
     dc2:	ff 0f       	add	r31, r31
     dc4:	bb 1f       	adc	r27, r27
     dc6:	66 1f       	adc	r22, r22
     dc8:	77 1f       	adc	r23, r23
     dca:	88 1f       	adc	r24, r24
     dcc:	c2 f7       	brpl	.-16     	; 0xdbe <__addsf3x+0x6e>
     dce:	0e c0       	rjmp	.+28     	; 0xdec <__addsf3x+0x9c>
     dd0:	ba 0f       	add	r27, r26
     dd2:	62 1f       	adc	r22, r18
     dd4:	73 1f       	adc	r23, r19
     dd6:	84 1f       	adc	r24, r20
     dd8:	48 f4       	brcc	.+18     	; 0xdec <__addsf3x+0x9c>
     dda:	87 95       	ror	r24
     ddc:	77 95       	ror	r23
     dde:	67 95       	ror	r22
     de0:	b7 95       	ror	r27
     de2:	f7 95       	ror	r31
     de4:	9e 3f       	cpi	r25, 0xFE	; 254
     de6:	08 f0       	brcs	.+2      	; 0xdea <__addsf3x+0x9a>
     de8:	b0 cf       	rjmp	.-160    	; 0xd4a <__addsf3+0x28>
     dea:	93 95       	inc	r25
     dec:	88 0f       	add	r24, r24
     dee:	08 f0       	brcs	.+2      	; 0xdf2 <__addsf3x+0xa2>
     df0:	99 27       	eor	r25, r25
     df2:	ee 0f       	add	r30, r30
     df4:	97 95       	ror	r25
     df6:	87 95       	ror	r24
     df8:	08 95       	ret

00000dfa <__fixsfsi>:
     dfa:	0e 94 04 07 	call	0xe08	; 0xe08 <__fixunssfsi>
     dfe:	68 94       	set
     e00:	b1 11       	cpse	r27, r1
     e02:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__fp_szero>
     e06:	08 95       	ret

00000e08 <__fixunssfsi>:
     e08:	0e 94 a0 07 	call	0xf40	; 0xf40 <__fp_splitA>
     e0c:	88 f0       	brcs	.+34     	; 0xe30 <__fixunssfsi+0x28>
     e0e:	9f 57       	subi	r25, 0x7F	; 127
     e10:	98 f0       	brcs	.+38     	; 0xe38 <__fixunssfsi+0x30>
     e12:	b9 2f       	mov	r27, r25
     e14:	99 27       	eor	r25, r25
     e16:	b7 51       	subi	r27, 0x17	; 23
     e18:	b0 f0       	brcs	.+44     	; 0xe46 <__fixunssfsi+0x3e>
     e1a:	e1 f0       	breq	.+56     	; 0xe54 <__fixunssfsi+0x4c>
     e1c:	66 0f       	add	r22, r22
     e1e:	77 1f       	adc	r23, r23
     e20:	88 1f       	adc	r24, r24
     e22:	99 1f       	adc	r25, r25
     e24:	1a f0       	brmi	.+6      	; 0xe2c <__fixunssfsi+0x24>
     e26:	ba 95       	dec	r27
     e28:	c9 f7       	brne	.-14     	; 0xe1c <__fixunssfsi+0x14>
     e2a:	14 c0       	rjmp	.+40     	; 0xe54 <__fixunssfsi+0x4c>
     e2c:	b1 30       	cpi	r27, 0x01	; 1
     e2e:	91 f0       	breq	.+36     	; 0xe54 <__fixunssfsi+0x4c>
     e30:	0e 94 ba 07 	call	0xf74	; 0xf74 <__fp_zero>
     e34:	b1 e0       	ldi	r27, 0x01	; 1
     e36:	08 95       	ret
     e38:	0c 94 ba 07 	jmp	0xf74	; 0xf74 <__fp_zero>
     e3c:	67 2f       	mov	r22, r23
     e3e:	78 2f       	mov	r23, r24
     e40:	88 27       	eor	r24, r24
     e42:	b8 5f       	subi	r27, 0xF8	; 248
     e44:	39 f0       	breq	.+14     	; 0xe54 <__fixunssfsi+0x4c>
     e46:	b9 3f       	cpi	r27, 0xF9	; 249
     e48:	cc f3       	brlt	.-14     	; 0xe3c <__fixunssfsi+0x34>
     e4a:	86 95       	lsr	r24
     e4c:	77 95       	ror	r23
     e4e:	67 95       	ror	r22
     e50:	b3 95       	inc	r27
     e52:	d9 f7       	brne	.-10     	; 0xe4a <__fixunssfsi+0x42>
     e54:	3e f4       	brtc	.+14     	; 0xe64 <__fixunssfsi+0x5c>
     e56:	90 95       	com	r25
     e58:	80 95       	com	r24
     e5a:	70 95       	com	r23
     e5c:	61 95       	neg	r22
     e5e:	7f 4f       	sbci	r23, 0xFF	; 255
     e60:	8f 4f       	sbci	r24, 0xFF	; 255
     e62:	9f 4f       	sbci	r25, 0xFF	; 255
     e64:	08 95       	ret

00000e66 <__floatunsisf>:
     e66:	e8 94       	clt
     e68:	09 c0       	rjmp	.+18     	; 0xe7c <__floatsisf+0x12>

00000e6a <__floatsisf>:
     e6a:	97 fb       	bst	r25, 7
     e6c:	3e f4       	brtc	.+14     	; 0xe7c <__floatsisf+0x12>
     e6e:	90 95       	com	r25
     e70:	80 95       	com	r24
     e72:	70 95       	com	r23
     e74:	61 95       	neg	r22
     e76:	7f 4f       	sbci	r23, 0xFF	; 255
     e78:	8f 4f       	sbci	r24, 0xFF	; 255
     e7a:	9f 4f       	sbci	r25, 0xFF	; 255
     e7c:	99 23       	and	r25, r25
     e7e:	a9 f0       	breq	.+42     	; 0xeaa <__floatsisf+0x40>
     e80:	f9 2f       	mov	r31, r25
     e82:	96 e9       	ldi	r25, 0x96	; 150
     e84:	bb 27       	eor	r27, r27
     e86:	93 95       	inc	r25
     e88:	f6 95       	lsr	r31
     e8a:	87 95       	ror	r24
     e8c:	77 95       	ror	r23
     e8e:	67 95       	ror	r22
     e90:	b7 95       	ror	r27
     e92:	f1 11       	cpse	r31, r1
     e94:	f8 cf       	rjmp	.-16     	; 0xe86 <__floatsisf+0x1c>
     e96:	fa f4       	brpl	.+62     	; 0xed6 <__floatsisf+0x6c>
     e98:	bb 0f       	add	r27, r27
     e9a:	11 f4       	brne	.+4      	; 0xea0 <__floatsisf+0x36>
     e9c:	60 ff       	sbrs	r22, 0
     e9e:	1b c0       	rjmp	.+54     	; 0xed6 <__floatsisf+0x6c>
     ea0:	6f 5f       	subi	r22, 0xFF	; 255
     ea2:	7f 4f       	sbci	r23, 0xFF	; 255
     ea4:	8f 4f       	sbci	r24, 0xFF	; 255
     ea6:	9f 4f       	sbci	r25, 0xFF	; 255
     ea8:	16 c0       	rjmp	.+44     	; 0xed6 <__floatsisf+0x6c>
     eaa:	88 23       	and	r24, r24
     eac:	11 f0       	breq	.+4      	; 0xeb2 <__floatsisf+0x48>
     eae:	96 e9       	ldi	r25, 0x96	; 150
     eb0:	11 c0       	rjmp	.+34     	; 0xed4 <__floatsisf+0x6a>
     eb2:	77 23       	and	r23, r23
     eb4:	21 f0       	breq	.+8      	; 0xebe <__floatsisf+0x54>
     eb6:	9e e8       	ldi	r25, 0x8E	; 142
     eb8:	87 2f       	mov	r24, r23
     eba:	76 2f       	mov	r23, r22
     ebc:	05 c0       	rjmp	.+10     	; 0xec8 <__floatsisf+0x5e>
     ebe:	66 23       	and	r22, r22
     ec0:	71 f0       	breq	.+28     	; 0xede <__floatsisf+0x74>
     ec2:	96 e8       	ldi	r25, 0x86	; 134
     ec4:	86 2f       	mov	r24, r22
     ec6:	70 e0       	ldi	r23, 0x00	; 0
     ec8:	60 e0       	ldi	r22, 0x00	; 0
     eca:	2a f0       	brmi	.+10     	; 0xed6 <__floatsisf+0x6c>
     ecc:	9a 95       	dec	r25
     ece:	66 0f       	add	r22, r22
     ed0:	77 1f       	adc	r23, r23
     ed2:	88 1f       	adc	r24, r24
     ed4:	da f7       	brpl	.-10     	; 0xecc <__floatsisf+0x62>
     ed6:	88 0f       	add	r24, r24
     ed8:	96 95       	lsr	r25
     eda:	87 95       	ror	r24
     edc:	97 f9       	bld	r25, 7
     ede:	08 95       	ret

00000ee0 <__fp_inf>:
     ee0:	97 f9       	bld	r25, 7
     ee2:	9f 67       	ori	r25, 0x7F	; 127
     ee4:	80 e8       	ldi	r24, 0x80	; 128
     ee6:	70 e0       	ldi	r23, 0x00	; 0
     ee8:	60 e0       	ldi	r22, 0x00	; 0
     eea:	08 95       	ret

00000eec <__fp_nan>:
     eec:	9f ef       	ldi	r25, 0xFF	; 255
     eee:	80 ec       	ldi	r24, 0xC0	; 192
     ef0:	08 95       	ret

00000ef2 <__fp_pscA>:
     ef2:	00 24       	eor	r0, r0
     ef4:	0a 94       	dec	r0
     ef6:	16 16       	cp	r1, r22
     ef8:	17 06       	cpc	r1, r23
     efa:	18 06       	cpc	r1, r24
     efc:	09 06       	cpc	r0, r25
     efe:	08 95       	ret

00000f00 <__fp_pscB>:
     f00:	00 24       	eor	r0, r0
     f02:	0a 94       	dec	r0
     f04:	12 16       	cp	r1, r18
     f06:	13 06       	cpc	r1, r19
     f08:	14 06       	cpc	r1, r20
     f0a:	05 06       	cpc	r0, r21
     f0c:	08 95       	ret

00000f0e <__fp_round>:
     f0e:	09 2e       	mov	r0, r25
     f10:	03 94       	inc	r0
     f12:	00 0c       	add	r0, r0
     f14:	11 f4       	brne	.+4      	; 0xf1a <__fp_round+0xc>
     f16:	88 23       	and	r24, r24
     f18:	52 f0       	brmi	.+20     	; 0xf2e <__fp_round+0x20>
     f1a:	bb 0f       	add	r27, r27
     f1c:	40 f4       	brcc	.+16     	; 0xf2e <__fp_round+0x20>
     f1e:	bf 2b       	or	r27, r31
     f20:	11 f4       	brne	.+4      	; 0xf26 <__fp_round+0x18>
     f22:	60 ff       	sbrs	r22, 0
     f24:	04 c0       	rjmp	.+8      	; 0xf2e <__fp_round+0x20>
     f26:	6f 5f       	subi	r22, 0xFF	; 255
     f28:	7f 4f       	sbci	r23, 0xFF	; 255
     f2a:	8f 4f       	sbci	r24, 0xFF	; 255
     f2c:	9f 4f       	sbci	r25, 0xFF	; 255
     f2e:	08 95       	ret

00000f30 <__fp_split3>:
     f30:	57 fd       	sbrc	r21, 7
     f32:	90 58       	subi	r25, 0x80	; 128
     f34:	44 0f       	add	r20, r20
     f36:	55 1f       	adc	r21, r21
     f38:	59 f0       	breq	.+22     	; 0xf50 <__fp_splitA+0x10>
     f3a:	5f 3f       	cpi	r21, 0xFF	; 255
     f3c:	71 f0       	breq	.+28     	; 0xf5a <__fp_splitA+0x1a>
     f3e:	47 95       	ror	r20

00000f40 <__fp_splitA>:
     f40:	88 0f       	add	r24, r24
     f42:	97 fb       	bst	r25, 7
     f44:	99 1f       	adc	r25, r25
     f46:	61 f0       	breq	.+24     	; 0xf60 <__fp_splitA+0x20>
     f48:	9f 3f       	cpi	r25, 0xFF	; 255
     f4a:	79 f0       	breq	.+30     	; 0xf6a <__fp_splitA+0x2a>
     f4c:	87 95       	ror	r24
     f4e:	08 95       	ret
     f50:	12 16       	cp	r1, r18
     f52:	13 06       	cpc	r1, r19
     f54:	14 06       	cpc	r1, r20
     f56:	55 1f       	adc	r21, r21
     f58:	f2 cf       	rjmp	.-28     	; 0xf3e <__fp_split3+0xe>
     f5a:	46 95       	lsr	r20
     f5c:	f1 df       	rcall	.-30     	; 0xf40 <__fp_splitA>
     f5e:	08 c0       	rjmp	.+16     	; 0xf70 <__fp_splitA+0x30>
     f60:	16 16       	cp	r1, r22
     f62:	17 06       	cpc	r1, r23
     f64:	18 06       	cpc	r1, r24
     f66:	99 1f       	adc	r25, r25
     f68:	f1 cf       	rjmp	.-30     	; 0xf4c <__fp_splitA+0xc>
     f6a:	86 95       	lsr	r24
     f6c:	71 05       	cpc	r23, r1
     f6e:	61 05       	cpc	r22, r1
     f70:	08 94       	sec
     f72:	08 95       	ret

00000f74 <__fp_zero>:
     f74:	e8 94       	clt

00000f76 <__fp_szero>:
     f76:	bb 27       	eor	r27, r27
     f78:	66 27       	eor	r22, r22
     f7a:	77 27       	eor	r23, r23
     f7c:	cb 01       	movw	r24, r22
     f7e:	97 f9       	bld	r25, 7
     f80:	08 95       	ret

00000f82 <__mulsf3>:
     f82:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <__mulsf3x>
     f86:	0c 94 87 07 	jmp	0xf0e	; 0xf0e <__fp_round>
     f8a:	0e 94 79 07 	call	0xef2	; 0xef2 <__fp_pscA>
     f8e:	38 f0       	brcs	.+14     	; 0xf9e <__mulsf3+0x1c>
     f90:	0e 94 80 07 	call	0xf00	; 0xf00 <__fp_pscB>
     f94:	20 f0       	brcs	.+8      	; 0xf9e <__mulsf3+0x1c>
     f96:	95 23       	and	r25, r21
     f98:	11 f0       	breq	.+4      	; 0xf9e <__mulsf3+0x1c>
     f9a:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__fp_inf>
     f9e:	0c 94 76 07 	jmp	0xeec	; 0xeec <__fp_nan>
     fa2:	11 24       	eor	r1, r1
     fa4:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__fp_szero>

00000fa8 <__mulsf3x>:
     fa8:	0e 94 98 07 	call	0xf30	; 0xf30 <__fp_split3>
     fac:	70 f3       	brcs	.-36     	; 0xf8a <__mulsf3+0x8>

00000fae <__mulsf3_pse>:
     fae:	95 9f       	mul	r25, r21
     fb0:	c1 f3       	breq	.-16     	; 0xfa2 <__mulsf3+0x20>
     fb2:	95 0f       	add	r25, r21
     fb4:	50 e0       	ldi	r21, 0x00	; 0
     fb6:	55 1f       	adc	r21, r21
     fb8:	62 9f       	mul	r22, r18
     fba:	f0 01       	movw	r30, r0
     fbc:	72 9f       	mul	r23, r18
     fbe:	bb 27       	eor	r27, r27
     fc0:	f0 0d       	add	r31, r0
     fc2:	b1 1d       	adc	r27, r1
     fc4:	63 9f       	mul	r22, r19
     fc6:	aa 27       	eor	r26, r26
     fc8:	f0 0d       	add	r31, r0
     fca:	b1 1d       	adc	r27, r1
     fcc:	aa 1f       	adc	r26, r26
     fce:	64 9f       	mul	r22, r20
     fd0:	66 27       	eor	r22, r22
     fd2:	b0 0d       	add	r27, r0
     fd4:	a1 1d       	adc	r26, r1
     fd6:	66 1f       	adc	r22, r22
     fd8:	82 9f       	mul	r24, r18
     fda:	22 27       	eor	r18, r18
     fdc:	b0 0d       	add	r27, r0
     fde:	a1 1d       	adc	r26, r1
     fe0:	62 1f       	adc	r22, r18
     fe2:	73 9f       	mul	r23, r19
     fe4:	b0 0d       	add	r27, r0
     fe6:	a1 1d       	adc	r26, r1
     fe8:	62 1f       	adc	r22, r18
     fea:	83 9f       	mul	r24, r19
     fec:	a0 0d       	add	r26, r0
     fee:	61 1d       	adc	r22, r1
     ff0:	22 1f       	adc	r18, r18
     ff2:	74 9f       	mul	r23, r20
     ff4:	33 27       	eor	r19, r19
     ff6:	a0 0d       	add	r26, r0
     ff8:	61 1d       	adc	r22, r1
     ffa:	23 1f       	adc	r18, r19
     ffc:	84 9f       	mul	r24, r20
     ffe:	60 0d       	add	r22, r0
    1000:	21 1d       	adc	r18, r1
    1002:	82 2f       	mov	r24, r18
    1004:	76 2f       	mov	r23, r22
    1006:	6a 2f       	mov	r22, r26
    1008:	11 24       	eor	r1, r1
    100a:	9f 57       	subi	r25, 0x7F	; 127
    100c:	50 40       	sbci	r21, 0x00	; 0
    100e:	9a f0       	brmi	.+38     	; 0x1036 <__mulsf3_pse+0x88>
    1010:	f1 f0       	breq	.+60     	; 0x104e <__mulsf3_pse+0xa0>
    1012:	88 23       	and	r24, r24
    1014:	4a f0       	brmi	.+18     	; 0x1028 <__mulsf3_pse+0x7a>
    1016:	ee 0f       	add	r30, r30
    1018:	ff 1f       	adc	r31, r31
    101a:	bb 1f       	adc	r27, r27
    101c:	66 1f       	adc	r22, r22
    101e:	77 1f       	adc	r23, r23
    1020:	88 1f       	adc	r24, r24
    1022:	91 50       	subi	r25, 0x01	; 1
    1024:	50 40       	sbci	r21, 0x00	; 0
    1026:	a9 f7       	brne	.-22     	; 0x1012 <__mulsf3_pse+0x64>
    1028:	9e 3f       	cpi	r25, 0xFE	; 254
    102a:	51 05       	cpc	r21, r1
    102c:	80 f0       	brcs	.+32     	; 0x104e <__mulsf3_pse+0xa0>
    102e:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__fp_inf>
    1032:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__fp_szero>
    1036:	5f 3f       	cpi	r21, 0xFF	; 255
    1038:	e4 f3       	brlt	.-8      	; 0x1032 <__mulsf3_pse+0x84>
    103a:	98 3e       	cpi	r25, 0xE8	; 232
    103c:	d4 f3       	brlt	.-12     	; 0x1032 <__mulsf3_pse+0x84>
    103e:	86 95       	lsr	r24
    1040:	77 95       	ror	r23
    1042:	67 95       	ror	r22
    1044:	b7 95       	ror	r27
    1046:	f7 95       	ror	r31
    1048:	e7 95       	ror	r30
    104a:	9f 5f       	subi	r25, 0xFF	; 255
    104c:	c1 f7       	brne	.-16     	; 0x103e <__mulsf3_pse+0x90>
    104e:	fe 2b       	or	r31, r30
    1050:	88 0f       	add	r24, r24
    1052:	91 1d       	adc	r25, r1
    1054:	96 95       	lsr	r25
    1056:	87 95       	ror	r24
    1058:	97 f9       	bld	r25, 7
    105a:	08 95       	ret

0000105c <__divmodhi4>:
    105c:	97 fb       	bst	r25, 7
    105e:	07 2e       	mov	r0, r23
    1060:	16 f4       	brtc	.+4      	; 0x1066 <__divmodhi4+0xa>
    1062:	00 94       	com	r0
    1064:	07 d0       	rcall	.+14     	; 0x1074 <__divmodhi4_neg1>
    1066:	77 fd       	sbrc	r23, 7
    1068:	09 d0       	rcall	.+18     	; 0x107c <__divmodhi4_neg2>
    106a:	0e 94 73 08 	call	0x10e6	; 0x10e6 <__udivmodhi4>
    106e:	07 fc       	sbrc	r0, 7
    1070:	05 d0       	rcall	.+10     	; 0x107c <__divmodhi4_neg2>
    1072:	3e f4       	brtc	.+14     	; 0x1082 <__divmodhi4_exit>

00001074 <__divmodhi4_neg1>:
    1074:	90 95       	com	r25
    1076:	81 95       	neg	r24
    1078:	9f 4f       	sbci	r25, 0xFF	; 255
    107a:	08 95       	ret

0000107c <__divmodhi4_neg2>:
    107c:	70 95       	com	r23
    107e:	61 95       	neg	r22
    1080:	7f 4f       	sbci	r23, 0xFF	; 255

00001082 <__divmodhi4_exit>:
    1082:	08 95       	ret

00001084 <__udivmodsi4>:
    1084:	a1 e2       	ldi	r26, 0x21	; 33
    1086:	1a 2e       	mov	r1, r26
    1088:	aa 1b       	sub	r26, r26
    108a:	bb 1b       	sub	r27, r27
    108c:	fd 01       	movw	r30, r26
    108e:	0d c0       	rjmp	.+26     	; 0x10aa <__udivmodsi4_ep>

00001090 <__udivmodsi4_loop>:
    1090:	aa 1f       	adc	r26, r26
    1092:	bb 1f       	adc	r27, r27
    1094:	ee 1f       	adc	r30, r30
    1096:	ff 1f       	adc	r31, r31
    1098:	a2 17       	cp	r26, r18
    109a:	b3 07       	cpc	r27, r19
    109c:	e4 07       	cpc	r30, r20
    109e:	f5 07       	cpc	r31, r21
    10a0:	20 f0       	brcs	.+8      	; 0x10aa <__udivmodsi4_ep>
    10a2:	a2 1b       	sub	r26, r18
    10a4:	b3 0b       	sbc	r27, r19
    10a6:	e4 0b       	sbc	r30, r20
    10a8:	f5 0b       	sbc	r31, r21

000010aa <__udivmodsi4_ep>:
    10aa:	66 1f       	adc	r22, r22
    10ac:	77 1f       	adc	r23, r23
    10ae:	88 1f       	adc	r24, r24
    10b0:	99 1f       	adc	r25, r25
    10b2:	1a 94       	dec	r1
    10b4:	69 f7       	brne	.-38     	; 0x1090 <__udivmodsi4_loop>
    10b6:	60 95       	com	r22
    10b8:	70 95       	com	r23
    10ba:	80 95       	com	r24
    10bc:	90 95       	com	r25
    10be:	9b 01       	movw	r18, r22
    10c0:	ac 01       	movw	r20, r24
    10c2:	bd 01       	movw	r22, r26
    10c4:	cf 01       	movw	r24, r30
    10c6:	08 95       	ret

000010c8 <__umulhisi3>:
    10c8:	a2 9f       	mul	r26, r18
    10ca:	b0 01       	movw	r22, r0
    10cc:	b3 9f       	mul	r27, r19
    10ce:	c0 01       	movw	r24, r0
    10d0:	a3 9f       	mul	r26, r19
    10d2:	70 0d       	add	r23, r0
    10d4:	81 1d       	adc	r24, r1
    10d6:	11 24       	eor	r1, r1
    10d8:	91 1d       	adc	r25, r1
    10da:	b2 9f       	mul	r27, r18
    10dc:	70 0d       	add	r23, r0
    10de:	81 1d       	adc	r24, r1
    10e0:	11 24       	eor	r1, r1
    10e2:	91 1d       	adc	r25, r1
    10e4:	08 95       	ret

000010e6 <__udivmodhi4>:
    10e6:	aa 1b       	sub	r26, r26
    10e8:	bb 1b       	sub	r27, r27
    10ea:	51 e1       	ldi	r21, 0x11	; 17
    10ec:	07 c0       	rjmp	.+14     	; 0x10fc <__udivmodhi4_ep>

000010ee <__udivmodhi4_loop>:
    10ee:	aa 1f       	adc	r26, r26
    10f0:	bb 1f       	adc	r27, r27
    10f2:	a6 17       	cp	r26, r22
    10f4:	b7 07       	cpc	r27, r23
    10f6:	10 f0       	brcs	.+4      	; 0x10fc <__udivmodhi4_ep>
    10f8:	a6 1b       	sub	r26, r22
    10fa:	b7 0b       	sbc	r27, r23

000010fc <__udivmodhi4_ep>:
    10fc:	88 1f       	adc	r24, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	5a 95       	dec	r21
    1102:	a9 f7       	brne	.-22     	; 0x10ee <__udivmodhi4_loop>
    1104:	80 95       	com	r24
    1106:	90 95       	com	r25
    1108:	bc 01       	movw	r22, r24
    110a:	cd 01       	movw	r24, r26
    110c:	08 95       	ret

0000110e <__itoa_ncheck>:
    110e:	bb 27       	eor	r27, r27
    1110:	4a 30       	cpi	r20, 0x0A	; 10
    1112:	31 f4       	brne	.+12     	; 0x1120 <__itoa_ncheck+0x12>
    1114:	99 23       	and	r25, r25
    1116:	22 f4       	brpl	.+8      	; 0x1120 <__itoa_ncheck+0x12>
    1118:	bd e2       	ldi	r27, 0x2D	; 45
    111a:	90 95       	com	r25
    111c:	81 95       	neg	r24
    111e:	9f 4f       	sbci	r25, 0xFF	; 255
    1120:	0c 94 93 08 	jmp	0x1126	; 0x1126 <__utoa_common>

00001124 <__utoa_ncheck>:
    1124:	bb 27       	eor	r27, r27

00001126 <__utoa_common>:
    1126:	fb 01       	movw	r30, r22
    1128:	55 27       	eor	r21, r21
    112a:	aa 27       	eor	r26, r26
    112c:	88 0f       	add	r24, r24
    112e:	99 1f       	adc	r25, r25
    1130:	aa 1f       	adc	r26, r26
    1132:	a4 17       	cp	r26, r20
    1134:	10 f0       	brcs	.+4      	; 0x113a <__utoa_common+0x14>
    1136:	a4 1b       	sub	r26, r20
    1138:	83 95       	inc	r24
    113a:	50 51       	subi	r21, 0x10	; 16
    113c:	b9 f7       	brne	.-18     	; 0x112c <__utoa_common+0x6>
    113e:	a0 5d       	subi	r26, 0xD0	; 208
    1140:	aa 33       	cpi	r26, 0x3A	; 58
    1142:	08 f0       	brcs	.+2      	; 0x1146 <__utoa_common+0x20>
    1144:	a9 5d       	subi	r26, 0xD9	; 217
    1146:	a1 93       	st	Z+, r26
    1148:	00 97       	sbiw	r24, 0x00	; 0
    114a:	79 f7       	brne	.-34     	; 0x112a <__utoa_common+0x4>
    114c:	b1 11       	cpse	r27, r1
    114e:	b1 93       	st	Z+, r27
    1150:	11 92       	st	Z+, r1
    1152:	cb 01       	movw	r24, r22
    1154:	0c 94 ac 08 	jmp	0x1158	; 0x1158 <strrev>

00001158 <strrev>:
    1158:	dc 01       	movw	r26, r24
    115a:	fc 01       	movw	r30, r24
    115c:	67 2f       	mov	r22, r23
    115e:	71 91       	ld	r23, Z+
    1160:	77 23       	and	r23, r23
    1162:	e1 f7       	brne	.-8      	; 0x115c <strrev+0x4>
    1164:	32 97       	sbiw	r30, 0x02	; 2
    1166:	04 c0       	rjmp	.+8      	; 0x1170 <strrev+0x18>
    1168:	7c 91       	ld	r23, X
    116a:	6d 93       	st	X+, r22
    116c:	70 83       	st	Z, r23
    116e:	62 91       	ld	r22, -Z
    1170:	ae 17       	cp	r26, r30
    1172:	bf 07       	cpc	r27, r31
    1174:	c8 f3       	brcs	.-14     	; 0x1168 <strrev+0x10>
    1176:	08 95       	ret

00001178 <_exit>:
    1178:	f8 94       	cli

0000117a <__stop_program>:
    117a:	ff cf       	rjmp	.-2      	; 0x117a <__stop_program>
